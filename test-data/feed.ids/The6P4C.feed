<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>💖 the6p4c 🦈</title><link href="https://the6p4c.github.io/" rel="alternate"></link><link href="https://the6p4c.github.io/posts.xml" rel="self"></link><id>https://the6p4c.github.io/</id><updated>2022-06-13T00:00:00+10:00</updated><entry><title>STxP70/STHORM/P2012 - ST's secret microcontroller</title><link href="https://the6p4c.github.io/2022/06/13/stxp70-sthorm-p2012.html" rel="alternate"></link><published>2022-06-13T00:00:00+10:00</published><updated>2022-06-13T00:00:00+10:00</updated><author><name></name></author><id>tag:the6p4c.github.io,2022-06-13:/2022/06/13/stxp70-sthorm-p2012.html</id><summary type="html">&lt;p&gt;I have no ISA docs and I must RE&lt;/p&gt;</summary><content type="html">&lt;p&gt;ST has this "Time-of-Flight 8x8 multizone ranging sensor with wide field of view"... thing, called the &lt;a href="https://www.st.com/en/imaging-and-photonics-solutions/vl53l5cx.html"&gt;VL53L5CX&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="/assets/stxp70-sthorm-p2012/vl53l5cx.jpg"&gt;&lt;/p&gt;
&lt;p&gt;There's a line in the datasheet, under the Features heading - "Low-power microcontroller running Firmware". Ignoring that "having firmware" is apparently a cool enough feature to bother listing in your datasheet, it means there's some kind of processor inside this thing. So, uh, we need its firmware. Not the firmware that interfaces with the sensor, but the firmware that runs on the sensor itself. Why? Because we do.&lt;/p&gt;
&lt;p&gt;If we download the &lt;a href="https://www.st.com/content/st_com/en/products/embedded-software/imaging-software/stsw-img023.html"&gt;"Ultra Lite Driver"&lt;/a&gt;, and take a peek at the initialisation stuff within &lt;code&gt;VL53L5CX_ULD_API/src/vl53l5cx_api.c&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;uint8_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;vl53l5cx_init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;VL53L5CX_Configuration&lt;/span&gt;&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;p_dev&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="c1"&gt;// ...&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* Enable FW access */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;status&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;WrByte&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p_dev&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;platform&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x03&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x0D&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;status&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;WrByte&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p_dev&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;platform&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x7fff&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x01&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;status&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;_vl53l5cx_poll_for_answer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p_dev&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x21&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x10&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;status&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;WrByte&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p_dev&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;platform&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x7fff&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x00&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="c1"&gt;// ...&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* Download FW into VL53L5 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;status&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;WrByte&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p_dev&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;platform&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x7fff&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x09&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;status&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;WrMulti&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p_dev&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;platform&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;uint8_t&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;VL53L5CX_FIRMWARE&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="mh"&gt;0x8000&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;status&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;WrByte&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p_dev&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;platform&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x7fff&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x0a&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;status&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;WrMulti&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p_dev&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;platform&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;uint8_t&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;VL53L5CX_FIRMWARE&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;0x8000&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="mh"&gt;0x8000&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;status&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;WrByte&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p_dev&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;platform&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x7fff&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x0b&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;status&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;WrMulti&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p_dev&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;platform&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;uint8_t&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;VL53L5CX_FIRMWARE&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;0x10000&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="mh"&gt;0x5000&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;status&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;WrByte&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p_dev&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;platform&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x7fff&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x01&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="c1"&gt;// ...&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p class="caption-plain" style="font-size: 20pt;"&gt;🐶💭 🥺🥺💕&lt;/p&gt;
&lt;p&gt;So the driver definitely contains some of the sensor's firmware. That &lt;code&gt;VL53L5CX_FIRMWARE&lt;/code&gt; array, from &lt;code&gt;VL53L5CX_ULD_API/inc/vl53l5cx_buffers.h&lt;/code&gt;, is just a huge array of bytes:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt; * @brief This buffer contains the VL53L5CX firmware (MM1.3)&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;uint8_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;VL53L5CX_FIRMWARE&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0xe0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x04&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x07&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x68&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0xe0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x04&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x28&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0xe0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x04&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x09&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x68&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0xe0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x64&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x1a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0xc8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="c1"&gt;// ...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;With some vim booping (basically &lt;code&gt;%s%\(0x\|,\)%%g&lt;/code&gt; to remove all &lt;code&gt;0x&lt;/code&gt;es and &lt;code&gt;,&lt;/code&gt;s), we can strip all the C flourish away and end up with some hex data - &lt;code&gt;e0 04 07 68&lt;/code&gt; on the first line, &lt;code&gt;e0 04 0f 28&lt;/code&gt; on the next, and so on - that we can pipe into &lt;code&gt;xxd -r -p&lt;/code&gt; to turn it back into binary data.&lt;/p&gt;
&lt;p&gt;Now that we have that, well:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ binwalk firmware.bin

DECIMAL       HEXADECIMAL     DESCRIPTION
--------------------------------------------------------------------------------

$ python ../_tools/cpu_rec/cpu_rec.py firmware.bin 
firmware.bin
    full(0x15000)       None
    chunk(0x400;2)      NDS32
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p class="caption"&gt;partially reformatted, and the annoying warning &lt;a href="https://github.com/airbus-seclab/cpu_rec"&gt;&lt;code&gt;cpu_rec&lt;/code&gt;&lt;/a&gt; always prints removed&lt;/p&gt;
&lt;p&gt;Looks like we're on our own. That NDS32 chunk is most likely a red herring.&lt;/p&gt;
&lt;h1&gt;Who's that CPU?&lt;/h1&gt;
&lt;p&gt;There's a cute string in the initialisation code - &lt;code&gt;enable host access to go1&lt;/code&gt;. It sounds like the kind of string that might appear next to some other firmware loading code for another device using the same or similar CPU, that could shed more light on the whole situation. It's also unique enough that we're unlikely to find unrelated info. We can totally use it to go hunting for more relevant code.&lt;/p&gt;
&lt;p&gt;GitHub immediately shows us a kernel driver for the VL53L5 and a file called &lt;a href="https://github.com/iprouteth0/derpy_commit/blob/6944cb66297f8a7992f38914f9d4c4a2f1932cd1/drivers/input/misc/vl53L5/stmvl53l5_load_fw.c"&gt;&lt;code&gt;stmvl53l5_load_fw.c&lt;/code&gt;&lt;/a&gt;. It's got a lovely line at the top, which points us to the associated header file:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// from stmvl53l5_load_fw.c&lt;/span&gt;
&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;uint8_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;_fw_buffer&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;EWOKMZ_STXP70_TCPM_RAM_FULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="c1"&gt;// from stmvl53l5_load_fw.h&lt;/span&gt;
&lt;span class="cp"&gt;#define EWOKMZ_STXP70_TCPM_RAM_FULL { \&lt;/span&gt;
&lt;span class="cp"&gt;    0xe0, 0x00, 0x03, 0x08, \&lt;/span&gt;
&lt;span class="cp"&gt;    0xe0, 0x00, 0x0a, 0xc8, \&lt;/span&gt;
&lt;span class="cp"&gt;    0xe0, 0x00, 0x05, 0x08, \&lt;/span&gt;
&lt;span class="cp"&gt;    0xe0, 0x64, 0x33, 0xa8, \&lt;/span&gt;
&lt;span class="cp"&gt;    0xe0, 0x00, 0x0a, 0x88, \&lt;/span&gt;
&lt;span class="c1"&gt;// ...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p class="caption"&gt;&lt;s&gt;sickos_yes.jpg&lt;/s&gt; puppys_yes.jpg&lt;/p&gt;
&lt;p&gt;The FW looks quite similar, but the name of the preprocessor constant sheds a &lt;em&gt;ton&lt;/em&gt; of light on the situation. &lt;code&gt;EWOKMZ&lt;/code&gt; - bad start, not a clue (searching now, seems like the codename for the VL53L5?). &lt;code&gt;STXP70&lt;/code&gt; - hey, that sounds like a CPU name. &lt;code&gt;TCPM&lt;/code&gt; - maybe tightly-coupled program memory? &lt;code&gt;RAM_FULL&lt;/code&gt; - it's probably a complete copy of what needs to end up in RAM.&lt;/p&gt;
&lt;h1&gt;STXP70: so starts the saga&lt;/h1&gt;
&lt;p&gt;The STxP70, also known as the xP70, or the STxP70-v3, -v4 and -v4B for some specific variants, is. Something. Some kind of CPU core.&lt;/p&gt;
&lt;p&gt;ST seems to have let a lot more slip about what this core is in the past, but a lot of it has long since disappeared from the internet.&lt;/p&gt;
&lt;p class="caption"&gt;&lt;img alt="" src="/assets/stxp70-sthorm-p2012/stxp70.png"&gt;
from &lt;a href="http://www.artist-embedded.org/docs/Events/2010/Autrans/talks/PDF/Benini/BeniniAutrans10.ppt.pdf"&gt;a slideshow&lt;/a&gt;, but it has spoilers so don't look yet&lt;/p&gt;
&lt;p&gt;As far as I can tell, the STxP70 is a 32-bit RISC core developed by ST. It has a 7-stage pipeline, is dual issue in certain configurations (executes two instructions at once), and is highly extensible - supporting ISA extensions through additional hardware tacked onto the core.&lt;/p&gt;
&lt;p&gt;ST seems to have used (or still use?) the STxP70 as a general-purpose core to throw in devices. I think I've seen references to it in code as far back as 2008, so it's certainly not new. So far, I've found the core in this ranging sensor, &lt;a href="https://github.com/12019/vendor_st-ericsson/blob/5c3c8f4491a9996429c52ecc946bf76d3c4fc5a8/multimedia/imaging/isp_firmware/isp8500_firmware_IMX072/source/FW_src/isp_fw/PictorProject/LLA/lla_drv_common.c"&gt;in an image signal processor&lt;/a&gt; (namely the ISP8500, which only exists within some specific ST SoCs?), &lt;a href="https://www.st.com/resource/en/data_brief/sta660.pdf"&gt;in a DAB SoC&lt;/a&gt; as a DSP, &lt;a href="https://github.com/12019/vendor_st-ericsson/blob/5c3c8f4491a9996429c52ecc946bf76d3c4fc5a8/boot/issw/meminits/MB_PLATFORM_DV_W1044.5/mop_v20_v10_db8500b0_secst/db8500b0_soc_settings_toshiba_400mhz.c#L444-L446"&gt;as a management core&lt;/a&gt; doing DRAM init in that ST SoC (for set-top boxes and stuff, I think?), &lt;a href="https://github.com/torvalds/linux/blob/b14ffae378aa1db993e62b01392e70d1e585fb23/drivers/gpu/drm/sti/sti_hqvdp.c#L896"&gt;in an ST display controller&lt;/a&gt; (yet again in one of these set-top box SoCs), and probably a billion other places I haven't found.&lt;/p&gt;
&lt;p&gt;I've found a tiny bit about the instruction set and its encoding. We have a &lt;a href="https://github.com/12019/vendor_st-ericsson/blob/5c3c8f4491a9996429c52ecc946bf76d3c4fc5a8/multimedia/imaging/isp_firmware/isp8500_firmware_IMX072/source/FW_src/isp_fw/PictorProject/Misc/crt0.s"&gt;&lt;code&gt;crt0.s&lt;/code&gt;&lt;/a&gt;, ish, and &lt;a href="https://github.com/12019/vendor_st-ericsson/blob/5c3c8f4491a9996429c52ecc946bf76d3c4fc5a8/multimedia/imaging/isp_firmware/isp8500_firmware_IMX072/source/FW_src/isp_fw/PictorProject/Misc/ind_crt0.s"&gt;some other support stuff&lt;/a&gt; also written in assembly. Those (plus some of the limited stuff from docs before) also tell us we have predicated instruction execution (&lt;code&gt;g0?&lt;/code&gt; and other numbered predicate registers written before instructions) and apparently even hardware loop counters, although the block diagram above makes that seem like an optional feature. Immediates can be loaded into registers with &lt;code&gt;make&lt;/code&gt;, to load one half, and &lt;code&gt;more&lt;/code&gt; for the other half (it's not clear if &lt;code&gt;more&lt;/code&gt; loads the top half, or shifts the reg then loads the bottom half again). We've also got a single screenshot from the STWorkbench IDE that shows some instruction encodings - e.g. &lt;code&gt;e0 40 00 15&lt;/code&gt; for &lt;code&gt;G7? MAKE R0, 0x0&lt;/code&gt; (that &lt;code&gt;e0&lt;/code&gt; looks quite similar to how our sensor firmware began).&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="/assets/stxp70-sthorm-p2012/encoding.png"&gt;&lt;/p&gt;
&lt;h1&gt;P2012: the saga continues&lt;/h1&gt;
&lt;p&gt;P2012, also known as Platform 2012, sometimes Platform P2012, and renamed at some point to STHORM (also written as SThorm) is a combination of a variable number of STxP70 cores, in a multi-core processing arrangement. Either managed by one or two ARM cores, or yet another STxP70 core, it was intended to make some kind of splash in the space between CPU/GPGPU processing and custom silicon/gateware (note: this is what every project in this space tries to do). It seems to have been developed in conjunction with &lt;a href="https://www.cea.fr/"&gt;CEA&lt;/a&gt;, which to be honest might explain a bit about the secrecy.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="/assets/stxp70-sthorm-p2012/sthorm1.png"&gt;&lt;/p&gt;
&lt;p&gt;The P2012/STHORM seems to have got a &lt;em&gt;lot&lt;/em&gt; of attention in academia. For some reason. A lot of stuff about OpenCL/OpenMP. &lt;a href="https://scholar.google.com/scholar?q=STHORM"&gt;Google Scholar lists a loooot of papers&lt;/a&gt;. It also seems to have maybe made it into, again, &lt;a href="https://github.com/canalplus/r7oss/tree/fb30ac72c9e541f0eb8ef24a2899cd17e306733b/G6/src/havana2-sources-15.2.1.050.25.12.5_p1/linux/drivers/hevc_hard_host_transformer/STHORM"&gt;one of ST's STB SoCs&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The folks behind "BarbequeRTRM" (run-time resource manager) seem to have got their hands on a &lt;a href="https://www.youtube.com/watch?v=kDVtxV4NrVc"&gt;STHORM dev board&lt;/a&gt; (audio warning), which has the STHORM chip itself, a Zynq and way too many DC-DCs. That board in the video is also sitting atop some documentation I really want. But I still want the board.&lt;/p&gt;
&lt;p&gt;At first I thought the Zynq was running the STHORM as gateware, but &lt;a href="http://www.gipsa-lab.fr/~stephane.mocanu/slides_staars/lesecq.pdf"&gt;a slideshow&lt;/a&gt; from which the below slide is taken seems to indicate otherwise - the STHORM did actually get taped out.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="/assets/stxp70-sthorm-p2012/silicon.png"&gt;&lt;/p&gt;
&lt;p&gt;That also explains this lovely diagram - the host is the Zynq, with its dual A9 cores.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="/assets/stxp70-sthorm-p2012/sthorm2.png"&gt;&lt;/p&gt;
&lt;h1&gt;Loose ends&lt;/h1&gt;
&lt;h2&gt;Where can we get the STxP70 toolset?&lt;/h2&gt;
&lt;p&gt;It seems like this was available from ST at some point. It's a standard set of compilers and tools (the typical GNU-y collection), and the &lt;a href="https://www.st.com/resource/en/application_note/cd18218860-stxp70-how-to-build-and-test-embedded-software-stmicroelectronics.pdf"&gt;"how to build and test embedded software"&lt;/a&gt; application note (AN3505) and &lt;a href="https://manualzz.com/doc/37222804/stxp70-compiler---stmicroelectronics"&gt;compiler manual&lt;/a&gt; (UM1237) give some idea of the supplied tools. There's, at minimum, &lt;code&gt;st70xpcc&lt;/code&gt; (with a potential link to the &lt;a href="https://sourceforge.net/projects/open64/"&gt;Open64&lt;/a&gt; toolchain), &lt;code&gt;stxp70-ld&lt;/code&gt;, and &lt;code&gt;stxp70-as&lt;/code&gt;, then some additional tooling for running and debugging called &lt;code&gt;sxrun&lt;/code&gt; (simulator) and &lt;code&gt;sxgdb&lt;/code&gt;. An older compiler called &lt;code&gt;sxcc&lt;/code&gt; is mentioned, which the compiler manual says there's apparently compatibility with. There's the standard litany of &lt;code&gt;stxp70-readelf&lt;/code&gt; and &lt;code&gt;stxp70-objdump&lt;/code&gt; stuff too.&lt;/p&gt;
&lt;p&gt;I'm not sure why it's called a "toolset" but it appears to integrate tightly with STWorkbench.&lt;/p&gt;
&lt;p&gt;Some folder names I've come across so far look like &lt;code&gt;STxP70_Toolset_4_1_0_Patched&lt;/code&gt; and &lt;code&gt;STxP70_Toolset_2011.2_Patched&lt;/code&gt; from a &lt;a href="https://github.com/canalplus/r7oss/blob/fb30ac72c9e541f0eb8ef24a2899cd17e306733b/G6/src/transport_engine-sources-15.2.2.87.7.12.6/firmware/Makefile.fw#L6-L7"&gt;Makefile on GitHub&lt;/a&gt;. The compiler manual says there's at minimum also 2012.1, 2012.1 patch 001, 2012.2, 2012.2 Update 01, and 2013.1 versions.&lt;/p&gt;
&lt;h2&gt;Where are the other manuals referenced in AN3505?&lt;/h2&gt;
&lt;p&gt;There's mention of some documents I haven't been able to find:&lt;/p&gt;
&lt;p&gt;From AN3505:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;STxP70-4.4.0 core and instruction set architecture reference manual (Doc ID 023738)&lt;/li&gt;
&lt;li&gt;STxP70 professional toolset user manual (7833754)&lt;/li&gt;
&lt;li&gt;STxP70-4 utilities reference manual (8210925)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;From UM1237, but not in AN3505:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Advanced debugging with the STxP70-4 instruction-accurate simulator (Doc ID 024404)&lt;/li&gt;
&lt;li&gt;Building STxP70 libraries application note (8226669)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;From the BarbequeRTRM video:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;"STHORM evaluation kit"&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Where are they? Were they ever publicly available? Are they hiding on ST's website somewhere? Why are some of the documents on ST's site, and indexed, but these aren't? Can I please please please have the ISA reference manual? Please? 🥺&lt;/p&gt;
&lt;h2&gt;Where can we get the P2012 SDK?&lt;/h2&gt;
&lt;p&gt;Also seems like it was available at some point, through "Minalogic" at https://minalogic.net. This is since gone, but even in the day required signing an NDA and having a confirmed account to download.&lt;/p&gt;
&lt;p&gt;Some relevant filenames for the P2012 SDK include &lt;code&gt;p2012sdk-2012.2.zip&lt;/code&gt; from &lt;a href="https://dmmlib.microlab.ntua.gr/p2012sdk.html"&gt;dmmlib's P2012 SDK build instructions&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;What happened to P2012/STHORM?&lt;/h2&gt;
&lt;p&gt;It seems like there was a flurry of academic research between (maybe?) 2010 and up to even 2016. But somehow, despite all that, it seems not to exist outside of academia. Did it die? Commercial product never released? Commercial product released, but kept super secret? ST just enjoying the free work it's getting through academia? All the chips burnt up when the thermal management research went nowhere?&lt;/p&gt;
&lt;h1&gt;That's about it&lt;/h1&gt;
&lt;p&gt;I'd be here for weeks re-finding information if I tried to make this comprehensive. If you've found something, or have any questions, hit me up on Twitter.&lt;/p&gt;</content><category term="blog"></category><category term="reverse engineering"></category><category term="embedded"></category></entry><entry><title>More compression, in RAM init</title><link href="https://the6p4c.github.io/2022/06/02/compression.html" rel="alternate"></link><published>2022-06-02T00:00:00+10:00</published><updated>2022-06-02T00:00:00+10:00</updated><author><name></name></author><id>tag:the6p4c.github.io,2022-06-02:/2022/06/02/compression.html</id><summary type="html">&lt;p&gt;A lazy post about some compression I found&lt;/p&gt;</summary><content type="html">&lt;p&gt;this is meant to be quick and lazy so i'm gonna write like this. also this isn't meant to be a tutorial, i've probably forgotten to explain some stuff here and there but oh well.&lt;/p&gt;
&lt;p&gt;in a random firmware image (undisclosed not cause i don't want to tell you just cause it's not relevant) i got a bit caught up finding out how any strings, or. well. any of the ui was drawn to the lcd. there's a bit of a twisty maze of lcd-related function calls at various levels of the stack (drivers for the specific lcd, more generic drawing routines, stuff that read bitmaps from spi flash but seems to be a general bitmap drawing function that just sometimes reads stuff from flash? based on global flags, not on arguments? anyway).&lt;/p&gt;
&lt;p&gt;there seemed to be some sort of vtable or dynamic dispatch table for the lcd drawing routines, but where the pointer got initialised was kind of a mystery. i could find where it copied one pointer into the "context" structure&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1"&gt;1&lt;/a&gt;&lt;/sup&gt;, where the "context" structure's vtable pointer was what a bunch of other stuff (potentially?) made calls through. ok hindsight says i didn't really need to find the initialisation of the vtable, but "draw horizontal line" and "draw vertical line" do look very similar when you can't see the pixels. so it seemed like a decent foothold to gain.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;undefined4&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x48&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;_DAT_20000adc&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p class="caption"&gt;the offending vtable pointer initialisation&lt;/p&gt;
&lt;p&gt;so ok. vtable pointer comes from a ram address. but nothing seems to - there's no write references to &lt;code&gt;_DAT_20000adc&lt;/code&gt;. so ok, probably comes from the initialised section of ram, &lt;code&gt;.data&lt;/code&gt; or whatever. usually it's pretty easy to uncover where in flash the data which is to be copied into the initialised section of ram is - you find some function near the entry point that's inscrutable and looks nothing like the rest of the firmware, and references some kind of table-y thing somewhere in flash. that table usually contains either just (source, dest, length) tuples, sometimes (function pointer, argument list) tuples to allow more than just copying (zero init!)&lt;/p&gt;
&lt;h1&gt;here's where it gets odd&lt;/h1&gt;
&lt;p&gt;so this had a function like that, and a table like that.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;FUN_080e8b98&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;piVar1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;piVar1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;DAT_080e91f0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;piVar1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;UNK_080e9218&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;piVar1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;code&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)((&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;piVar1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;piVar1&lt;/span&gt;&lt;span class="p"&gt;))(&lt;/span&gt;&lt;span class="n"&gt;piVar1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;ddw FFFFDE55h # DAT_080e91f0 (the start pointer)
ddw B784h
ddw 10000000h
ddw 1BC70h
ddw 20002698h
ddw 0h
ddw FFFFBB49h
ddw 5F7Fh
ddw 1CCEh
ddw 20000000h
...           # UNK_080e9218 (the end pointer)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;some things seem familiar at first glance: these things love to use start and end pointers in their loops rather than lengths, and i see a function pointer being called. that looks a lot like our "function pointers and argument lists" style. but uh.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0xffffde55&lt;/code&gt; is not a function pointer. and why are we adding stuff to the function pointer. don't do that&lt;/p&gt;
&lt;p&gt;riiight, so. the function pointers are, offsets, relative to where those offsets are stored. you take the address where the &lt;code&gt;0xffffde55&lt;/code&gt; is stored, add &lt;code&gt;0xffffde55&lt;/code&gt; to it, and you land at a function. that offset is negative (32-bit, 2's complement) so it's somewhere in the firmware before this table. yuck.&lt;/p&gt;
&lt;p&gt;but that's fine, and in a way it's nice - we know the &lt;code&gt;0xffffbb49&lt;/code&gt; later on in this table is probably another function pointer, or at minimum another self-relative offset. that gives us info and we like info.&lt;/p&gt;
&lt;p&gt;ok so we inspect that first function, and it's not too bad. the pointer it gets passed is to the next value in the table, &lt;code&gt;0xb784&lt;/code&gt;, and that's a length. the function reads another value, &lt;code&gt;0x10000000&lt;/code&gt; - that's the destination pointer. and then zeros that many bytes at that address. it reads the next two values, uses those in the same way, reads that the next length is 0, realises that's the end marker, and returns. it returns the address of the &lt;code&gt;0xffffbb49&lt;/code&gt;, because it needs to tell the init table processing function how much data it just read and where the caller should pick up from.&lt;/p&gt;
&lt;p&gt;i'm not confused yet, this is fine&lt;/p&gt;
&lt;p&gt;the next one is the curveball. it reads those three values after it - &lt;code&gt;0x5f7f&lt;/code&gt;, &lt;code&gt;0x1cce&lt;/code&gt;, and &lt;code&gt;0x20000000&lt;/code&gt;. we know &lt;code&gt;0x20000000&lt;/code&gt; is gonna be ram, the other two look a bit like lengths. maybe one's another self-relative offset, but just a positive one. we'll have to look at the &lt;code&gt;0xffffbb49&lt;/code&gt; function.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;FUN_080e4d50&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;byte&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bVar1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;byte&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pbVar2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;byte&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pbVar3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;byte&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pbVar4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;uint&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;uVar5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;uint&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;uVar6&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;iVar7&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;uint&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;uVar8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;unaff_r9&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;uVar5&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;pbVar4&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;byte&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;pbVar2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;byte&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;uVar5&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x1f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;pbVar4&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pbVar4&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;unaff_r9&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pbVar2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pbVar2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;uVar5&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;bVar1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pbVar2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;uVar8&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bVar1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;pbVar3&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pbVar2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;bVar1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;pbVar3&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pbVar2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;uVar8&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pbVar2&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;uVar6&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;uint&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;bVar1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;uVar6&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0xf&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;uVar6&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pbVar3&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0xf&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;pbVar3&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pbVar3&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;uVar8&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;uVar8&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pbVar4&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pbVar3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;pbVar3&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pbVar3&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;pbVar4&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pbVar4&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;pbVar2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pbVar3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;uVar6&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;uVar8&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bVar1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;pbVar2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pbVar3&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;uVar8&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;pbVar2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pbVar3&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;uVar8&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;uint&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;pbVar3&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;pbVar3&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pbVar4&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;uint&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pbVar3&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;uVar8&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x100&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;iVar7&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;uVar6&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;iVar7&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;iVar7&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;-1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pbVar4&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pbVar3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;pbVar3&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pbVar3&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;pbVar4&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pbVar4&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;param_1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;w h a t&lt;/p&gt;
&lt;p&gt;the loop about half way down - &lt;code&gt;while (uVar8 -= 1, uVar8 != 0)&lt;/code&gt; and its body - looks like a pretty boring source to dest copy. what uh. what goes on in that last for loop, though.&lt;/p&gt;
&lt;h1&gt;compression&lt;/h1&gt;
&lt;p&gt;i'm not gonna show you the annotated and named and cleaned up version of that function, again, cause it's not important. you can re it yourself if you want - &lt;code&gt;param_1&lt;/code&gt; points to the &lt;code&gt;0x5f7f&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;we were a bit right. the &lt;code&gt;0x5f7f&lt;/code&gt; is another self-relative offset, to some more data. a bunch more - &lt;code&gt;0x1cce &amp;gt;&amp;gt; 1 = 0xe67&lt;/code&gt; bytes of data to be specific (this is the first little bit of that function!). it's, it's another table.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;00 FE 63 7C 77 7B F2 6B 6F C5 30 01 67 2B FE D7 AB 76 CA 82 C9 7D FA 59 47 F0 AD D4 A2 AF 9C A4 72 C0 B7 FD 93 26 36 3F F7 CC 34 A5 E5 F1 71 D8 31 15 04 C7 23 C3 18 96 05 9A 07 12 80 E2 EB 27 B2 75 09 83 2C 1A 1B 6E 5A ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p class="caption"&gt;truncated for your safety&lt;/p&gt;
&lt;p&gt;sooo. d'ya know about lzss? turns out this is a similar-ish "dictionary coding" compression algorithm. uh, go read about that &lt;a href="https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Storer%E2%80%93Szymanski"&gt;on wikipedia&lt;/a&gt; or &lt;a href="https://the6p4c.github.io/2019/11/27/investigating-compression.html"&gt;something i wrote a while ago&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;each entry in this table starts with a tag byte.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;0bAAAABBCC
    AAAA - compressed data length
    BB   - compressed data source offset (high byte)
    CC   - literal data length
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;then, since the 4 and 2 bit fields are pretty small, it does a bit of stuff to allow bigger values (in this order). if the literal data length was 0, read another byte, add 3 to the value, and use that as the literal data length instead. then, if the compressed data length was 15, read another byte, add 15 to the value, and use that as the compressed data length instead.&lt;/p&gt;
&lt;p&gt;then, from wherever you've ended up advancing the pointer to, read in the literal data. i.e., read literal data length bytes, and write them to the output.&lt;/p&gt;
&lt;p&gt;noooow we deal with the compression. if the compressed data length is 0, we go on to reading the next table entry straight away. if it's not 0, we immediately read another byte to act as the low byte of the compressed data source offset. then if the high byte of the offset from the tag was equal to 3, we read a byte (no adding 3!) and use it as the high byte. combine the two for the full 16-bit offset.&lt;/p&gt;
&lt;p&gt;once you've got it, seek that many bytes backwards in the output, read compressed data length bytes !plus two! (why) and write them out to the output (also keeping in mind it can totally read bytes that got written out to the file in this process back again - it's an easy way to create a repeating pattern).&lt;/p&gt;
&lt;p&gt;rinse and repeat. keep reading tags and their literal/compressed stuff until you've read &lt;code&gt;0x1cce &amp;gt;&amp;gt; 1 = 0xe67&lt;/code&gt; bytes from the table (it's not the decompressed length). or however many you have.&lt;/p&gt;
&lt;p&gt;that's a lot of text for it to all boil down to, that. also, idk if this is actually an existing compression format or not, but eh. i got my data out and my lcd vtable so i'm happy&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;lcd_default_vtable:
080e6fc4 dd 20 07 08       lcd_vtable
         ed 20 07 08 
         f9 20 07 08 ...
    080e6fc4 dd 20 07 08   void *   lcda_color_to_lcd+1      color_to_lcd
    080e6fc8 ed 20 07 08   void *   lcda_color_from_lcd+1    color_from_lcd
    080e6fcc f9 20 07 08   void *   FUN_080720f8+1           field2_0x8
    080e6fd0 47 75 02 08   void *   lcda_draw_bitmap+1       draw_bitmap_kinda
    080e6fd4 bd 74 02 08   void *   lcda_draw_hline+1        draw_hline
    080e6fd8 f3 74 02 08   void *   lcda_draw_vline+1        draw_vline
    080e6fdc 29 75 02 08   void *   lcda_draw_rect+1         draw_rect
    080e6fe0 85 74 02 08   void *   lcda_read_pixel+1        read_pixel
    080e6fe4 01 21 07 08   void *   lcda_get_bounds+1        get_bounds
    080e6fe8 61 74 02 08   void *   lcda_write_pixel+1       write_pixel
    080e6fec 9b 74 02 08   void *   lcda_invert_pixel+1      invert_pixel
    080e6ff0 b9 76 02 08   void *   FUN_080276b8+1           field11_0x2c
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p class="caption"&gt;yay&lt;/p&gt;
&lt;p&gt;did you come across this? &lt;a href="https://gist.github.com/the6p4c/ba52af73ece05829acf5335093b30609"&gt;here's some python&lt;/a&gt;. change the offset and length, give it the input file (with the compressed data) as the first arg and the output file (where to put the decompressed data) as the second and you should be good to go.&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;context is one of many reverse engineering ways of saying "thingy". i guess it's more specifically "thingy with a bunch of state for another thingy", but yeah&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="blog"></category><category term="reverse engineering"></category><category term="embedded"></category><category term="lazy"></category></entry><entry><title>Reverse engineering the Microchip RN-171 "WiFly"</title><link href="https://the6p4c.github.io/2020/07/15/rn-171.html" rel="alternate"></link><published>2020-07-15T00:00:00+10:00</published><updated>2020-07-15T00:00:00+10:00</updated><author><name></name></author><id>tag:the6p4c.github.io,2020-07-15:/2020/07/15/rn-171.html</id><summary type="html">&lt;p&gt;Flash file systems, "bootloaders" and SPARC.&lt;/p&gt;</summary><content type="html">&lt;p&gt;The urge is to make this write-up a typical "journey through the process", almost a step-by-step to RE this particular thing - but I think that betrays the true nature of reverse engineering. Besides, I've &lt;a href="https://the6p4c.github.io/2019/11/27/investigating-compression.html"&gt;done&lt;/a&gt; &lt;a href="https://the6p4c.github.io/2018/01/29/hacking-the-gc-part-2.html"&gt;that&lt;/a&gt; &lt;a href="https://the6p4c.github.io/2018/01/15/hacking-the-gc-part-1.html"&gt;before&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;There's nothing linear about this: new discoveries clarify previous assumptions, ideas you carelessly throw around or stumble upon become crucial to progress, and by gosh do you make a &lt;em&gt;ton&lt;/em&gt; of mistakes.&lt;/p&gt;
&lt;p&gt;Let's just talk about some interesting things instead.&lt;/p&gt;
&lt;p&gt;Reverse engineering has a strong reliance on breadth of knowledge. Plenty of "a-ha!" moments are when two concepts collide; when what you're seeing in a messy disassembly or a block of opaque hex suddenly looks familiar and the dominoes begin to topple. The hope is that this expands your breadth of knowledge, if only by just a bit, to create the familiarity that knocks over that first domino.&lt;/p&gt;
&lt;p&gt;&lt;img alt="The RN-171 on an RN-174p-EK dev board, and an RN-171 with the shield removed." src="https://the6p4c.github.io/assets/rn-171/module.png"&gt;&lt;/p&gt;
&lt;h1&gt;File systems, and flash file systems&lt;/h1&gt;
&lt;p&gt;Most storage media is divided into blocks on which basic read/write/erase operations are performed. Interacting with the media is at this block level - writing an individual byte means reading the entire block into memory, changing the byte of interest, then writing the modified block in its entirety back to the media. Flash media takes these block-level operations to another level, only guaranteeing you'll get anywhere from 1,000 to 1,000,000 erase/write operations per block before the block begins to fail and the data you read might no longer match the data you wrote.&lt;/p&gt;
&lt;p&gt;So, we'd like to store some files. Maybe we'll choose to take each file, write its filename and contents to the media, and then write the next file straight after it - blocks be damned. We'll add some length bytes to indicate how long the filename is and how many bytes the file's contents are, and pretend our media is simply a contiguous, byte-addressable memory. Problem solved, right? We've got a file system now, yeah?&lt;/p&gt;
&lt;p&gt;Maybe one of your files is a log, and you'd like to add a new message to the end. We've reached a snag - the next file starts on the byte immediately after the last byte of the file we're updating, so there's no room to just write another byte and increment the length. We could read every file after the one we're updating into memory, writing their filenames and data back to our storage media offset by one byte, then append our new data and update the file's length. Now every time you modify a file you need to rewrite tens, maybe hundreds or thousands of blocks - enjoy the delay if your file is near the start of the media, and watch your flash memory fail much quicker than you'd like.&lt;/p&gt;
&lt;h2&gt;Cluster chains&lt;/h2&gt;
&lt;p&gt;Instead of ignoring the blocky nature of our storage medium, let's embrace it. Rather than mandating that our files occupy a contiguous portion of our media, we'll form a chain of blocks which when read in the correct order, yield the contents of our file. Each block is either the end of the chain, or tells us which block contains the data which comes next.&lt;/p&gt;
&lt;p&gt;Updating a file becomes much easier now - find the last block of the file data, and check if it has any free space. If it does, we can write our new data to the last block and update the file's length, completing our operation. If the last block is full, or the amount of data we need to write is larger than the free space in the last block, we can add another block onto the chain to continue the file. Since each block points us to the next block in the chain, there's no need for adjacent data in the file to be stored in adjacent blocks. We're free to find an unused block anywhere and write our excess data to it.&lt;/p&gt;
&lt;p&gt;There's no one way to keep track of our chains. The FAT file system dedicates one or more blocks to the job (the &lt;a href="https://en.wikipedia.org/wiki/Design_of_the_FAT_file_system#Cluster_map"&gt;&lt;em&gt;cluster map&lt;/em&gt;&lt;/a&gt;), treating them as an array where &lt;code&gt;next_block = cluster_map[current_block]&lt;/code&gt;. A value of &lt;code&gt;next_block&lt;/code&gt; is dedicated to marking that the current block is the end of the chain. This approach isn't great for flash memory though, since every time we need to modify a chain we'd need to read/update/erase/write the cluster map, wearing one of the most important blocks in our file system out extremely quickly.&lt;/p&gt;
&lt;h2&gt;The RN-171's "tag flash file system"&lt;/h2&gt;
&lt;p&gt;Some of the firmware files distributed for the RN-171 are in a &lt;code&gt;mif&lt;/code&gt; format, containing several individual files (HTML documents, PNG images and executable code) which end up on the device. The contents of these &lt;code&gt;mif&lt;/code&gt; files are written directly into the module's external flash memory and thus contain a small file system suited to flash memory.&lt;/p&gt;
&lt;h3&gt;Chains&lt;/h3&gt;
&lt;p&gt;When we take a look at the first bytes of each 4 KiB (= 0x1000 byte) flash block, a curious pattern emerges.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;00000000: 00ff ffff 0301 ef02 045a 1e65 f101 0c64  .........Z.e...d
00001000: 01ff ffff 0301 ef02 045a 1e65 f101 076e  .........Z.e...n
00002000: 0203 ffff 0301 fcba 0440 00cc 80b5 0440  .........@.....@
00003000: 02fe ffff f090 1020 0070 002f 0ea2 16e0  ....... .p./....
00004000: 0405 ffff 0301 fcba 0440 00cc 20b5 0440  .........@.. ..@
00005000: 04ec ffff 0010 8600 e985 0052 8500 5550  ...........R..UP
00006000: 04ff ffff 2564 0d0a 4176 6572 6167 653d  ....%d..Average=
00007000: 0708 ffff 0301 fcba 0440 00d0 90b5 0440  .........@.....@
00008000: 07db ffff 5f45 6e72 6f6c 6c65 6542 7569  ...._EnrolleeBui
00009000: 090a ffff 0301 fcba 0440 0066 f0b5 0440  .........@.f...@
0000a000: 09d1 ffff 2845 4150 2069 6420 2564 2920  ....(EAP id %d)
0000b000: 0b0c ffff 0301 fcba 0440 0098 30b5 0440  .........@..0..@
0000c000: 0bc2 ffff f082 1040 0cc2 2340 0070 0097  .......@..#@.p..
0000d000: 0dff ffff 0301 fcba 0440 01f0 40b5 0440  .........@..@..@
0000e000: 0e0f ffff 0301 fcba 0440 01eb 30b5 0440  .........@..0..@
0000f000: 0eff ffff c204 a3e4 c200 4000 1080 0096  ..........@.....
00010000: 10ff ffff 0301 fcba 0440 01f3 20b5 0440  .........@.. ..@
# some bytes removed #
00023000: ffff ffff ffff ffff ffff ffff ffff ffff  ................
00024000: ffff ffff ffff ffff ffff ffff ffff ffff  ................
00025000: ffff ffff ffff ffff ffff ffff ffff ffff  ................
00026000: ffff ffff ffff ffff ffff ffff ffff ffff  ................
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Several blocks begin with their own address shifted right by 12 (i.e. divided by 0x1000) and the second byte of many blocks has a value not far off the first. Sometimes the first byte is &lt;code&gt;0xff&lt;/code&gt;, sometimes the second byte is &lt;code&gt;0xff&lt;/code&gt;, but the second byte is always &lt;code&gt;0xff&lt;/code&gt; if the first byte is &lt;code&gt;0xff&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This is the file system's chain tracking mechanism. Each block begins with two bytes indicating both the block where the chain starts, and the next block in the chain. If the block isn't part of a chain and is unused, the first byte is &lt;code&gt;0xff&lt;/code&gt;, and if the block is the end of a chain, the second byte is &lt;code&gt;0xff&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img alt="A diagram showing how the chain tags create a chain between blocks" src="https://the6p4c.github.io/assets/rn-171/chain_tag.png"&gt;&lt;/p&gt;
&lt;p&gt;Placing the chain data within each block is a much more flash-friendly approach than dedicating a block as FAT would. Adding another block to the chain requires rewriting only the last block of the file, to update the next block index, and deleting a file can be accomplished by erasing the page as it sets the start block index to &lt;code&gt;0xff&lt;/code&gt;. As such, the wear we put on the flash will be distributed around, rather than placed on a single block.&lt;/p&gt;
&lt;p&gt;To dump the file system contents, we can iterate through every block, identifying those that start a chain when their first byte matches the block's index (the address shifted right 12). We can then walk the chain using the next block index in each block's chain header to rip out the full file contents.&lt;/p&gt;
&lt;h3&gt;Tags&lt;/h3&gt;
&lt;p&gt;With the data from a bunch of chains in hand, we'll turn to deciphering how each file is structured. Some begin with some bytes and the filename, whereas others have their filename at the end of their data, in the last block of their chain.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# file beginning at block 00
00000000: 0301 ef02 045a 1e65 f101 0c64 756d 6d79  .....Z.e...dummy
00000010: 6361 6c2e 6461 74ff ffff ffff ffff ffff  cal.dat.........

# file beginning at block 0d
00000000: 0301 fcba 0440 01f0 40b5 0440 01f0 40bc  .....@..@..@..@.
00000010: 0413 5ba7 88b1 9c3e 0310 0000 c028 600c  ..[....&amp;gt;.....(`.
# some bytes removed #
00000fb0: 4001 f098 4001 f0a0 0204 5a1e 65f1 0115  @...@.....Z.e...
00000fc0: 6765 745f 6c69 622d 455a 582d 3438 332d  get_lib-EZX-483-
00000fd0: 7232 3134 311f 0101 ffff ffff ffff ffff  r2141...........
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;That discovery throws "fixed length header per-file" out the window. Instead, this file system takes a more abstract view of files as a collection of "tags", each with a type/identifier and some variable-length associated data. One tag stores the filename, another a bit mask of flags, and another the actual file contents.&lt;/p&gt;
&lt;p&gt;We can now step through the file tags manually. File 00 begins with an &lt;code&gt;03 01&lt;/code&gt;, a tag type &lt;code&gt;0x03&lt;/code&gt; with length &lt;code&gt;0x01&lt;/code&gt;, which gives it the value &lt;code&gt;0xef&lt;/code&gt;. Once we make our way to the filename, we see a tag beginning &lt;code&gt;01 0c&lt;/code&gt;: tag type &lt;code&gt;0x01&lt;/code&gt;, length &lt;code&gt;0x0c&lt;/code&gt;, which is exactly how long the string &lt;code&gt;dummycal.dat&lt;/code&gt; that follows is. Problem: what happens when a tag has more than &lt;code&gt;0xff&lt;/code&gt; bytes of data?&lt;/p&gt;
&lt;p&gt;A smart scheme's in play here. The quickest way to solve the problem of a field too narrow for the data it needs to store is to widen the field, but that's wasteful for the small tags which do have less than &lt;code&gt;0xff&lt;/code&gt; bytes of data associated with them. Instead, the tag length field is itself variable-length, storing only 7 bits of length data in each byte and using the 7th (top) bit to indicate if another length byte follows. In reality, the first length byte only stores 6 bits, as the 6th bit is dedicated to something I have no idea about, but the 7th bit still indicates if another length byte follows.&lt;/p&gt;
&lt;p&gt;Each subsequent byte's value is prepended to the binary string, meaning adding extra length bytes can only increase the value.&lt;/p&gt;
&lt;p&gt;&lt;img alt="A diagram showing how the length field is constructed from the length bytes" src="https://the6p4c.github.io/assets/rn-171/length_field.png"&gt;&lt;/p&gt;
&lt;p&gt;Now we're in a position to interpret the tags associated with each file to extract them in a more friendly way.&lt;/p&gt;
&lt;h2&gt;Binaries&lt;/h2&gt;
&lt;p&gt;Several of the files on the device are binaries - either applications that can be run, or libraries that are (assumedly) dynamically loaded by applications. Being split over several blocks of the flash, they're most likely loaded into RAM and executed there, rather than executed in-place (XIP). Inspecting the tags of the executable files shows two with promising address-like values: &lt;code&gt;0xb5&lt;/code&gt; and &lt;code&gt;0xba&lt;/code&gt;. Some experience suggests that one of these is likely to be a load address (where the binary should be copied into RAM) and the other the entry point (the address of the function to call to "start" the application), and determining which is which involves disassembling the binary assuming one address, and seeing how many cross-references in the assembly match up. When they all do, you've probably found the load address.&lt;/p&gt;
&lt;p&gt;One trap in doing this is accidentally relying on &lt;em&gt;relative&lt;/em&gt; data references, where the address of the data being accessed is specified relative to the instruction pointer. No matter the offset a binary is loaded to (in most cases) IP-relative references will always line up given a contiguous image, since +10 bytes is always +10 bytes, no matter where the image is in memory. Most of the time, jumps and calls are IP relative, so they're not great to rely on. Only &lt;em&gt;absolute&lt;/em&gt; data references can help determine if your binary has been given the correct load address.&lt;/p&gt;
&lt;p&gt;On SPARC, absolute references are often pairs of &lt;code&gt;sethi %hi(address_hi), reg&lt;/code&gt; and &lt;code&gt;or reg, address_lo, reg&lt;/code&gt; instructions, which together load the full address into a register.&lt;/p&gt;
&lt;p&gt;&lt;img alt="A disassembly listing showing the address 0x4000e400 being loaded into register o2 through a sethi and or instruction, which in the listing is annotated with the string beginning &amp;quot;wifly&amp;quot; it points to." src="https://the6p4c.github.io/assets/rn-171/valid_absolute_reference.png"&gt;&lt;/p&gt;
&lt;p&gt;Loading these binaries into a disassembler is now a matter of entering the right load address and poking around near the entry point for some valid assembly. In my extraction script, I took this a step further and dumped the binaries as ELF files - adding the machine code as a section located at the load address, and setting the entry point to the entry point from the &lt;code&gt;0xb5&lt;/code&gt; tag. Though I didn't end up using any of these ELF files in the process, I think in future it's a good idea to keep in mind, especially if I had further RE work to do on the applications.&lt;/p&gt;
&lt;h1&gt;Bootloader&lt;/h1&gt;
&lt;p&gt;Debug interfaces are often horrible: "undocumented" as the norm, "badly documented" as a reason to celebrate, and "well documented" an absolute sight to behold. Since we've no documentation whatsoever for the G2 Microsystems G2C543 microcontroller on the module, we're mostly in the dark, though the flashing tool is publicly available.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ ./flash_load.exe
flash_load
G2C547 Flash Loader Tool
Usage: flash_load [-h] [-d &amp;lt;dsu uart&amp;gt;] [-i &amp;lt;flash-image-file&amp;gt;] [-f] [-u] [-c] [-v]
    -h Display help.
    -d Serial port connected to the G2C547 DCOM flash loader port. Default: /dev/g2isp_dsu
    -i &amp;#39;flash.bin&amp;#39; image flle name to be loaded (mandatory).
    -f Enable fast dcom load interface.
    -u Use ISP Force awake and reset functionality when loading the device.
    -c Disable check for the calibration sector.
    -v Enable verbose debug output.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;References to a serial port are promising, since it increases the likelihood the debug adapter G2/Roving/Microchip would try and sell you is no more than a UART and some GPIO pins for forcing the device awake and resetting it. We're still limited by the fact the debug UART (separate from the UART the dev board exposes on the USB connector) is only broken out in a 0.2 mm pitch header (the left most on the dev board pictured above), but some magnet wire, a 0.1" header, and a 3V3 USB UART solves that.&lt;/p&gt;
&lt;p&gt;Delving into the binary gives promising signs along with plenty of debug symbols left over.&lt;/p&gt;
&lt;p&gt;&lt;img alt="The flash_load executable disassembled in Ghidra. The disassembly of the _prepare_device_and_connect function is visible, which ends with a call to a UART transmission function, passed a variable with the name _boot_loader_sequence." src="https://the6p4c.github.io/assets/rn-171/flash_load_boot_loader_sequence.png"&gt;&lt;/p&gt;
&lt;p&gt;As it turns out, this &lt;code&gt;0x4ec8&lt;/code&gt; byte long payload sent to the device is simply machine code with some framing to wake the chip up, tell it where in RAM to write the code, and how long the code is. This isn't an uncommon technique for devices to allow in-circuit programming, as it allows the method of programming to be changed after the device is taped out or almost completely overhauled. It can also allow for non-programming behaviour such as reading out the contents of an EEPROM without having to build the feature into the base firmware - just by modifying the payload which is sent to the device to do the job.&lt;/p&gt;
&lt;p&gt;In this case, the firmware sent to the device implements an interface which allows the SPI flash to be read from and written to, but most importantly, allows arbitrary reads and writes to memory!&lt;/p&gt;
&lt;p&gt;&lt;img alt="The _flash_interface_init function disassembled. Two calls are visible: _dma_uart_read_word and _dma_uart_write_word, which both take an address parameter." src="https://the6p4c.github.io/assets/rn-171/flash_load_read_write.png"&gt;&lt;/p&gt;
&lt;p&gt;Capturing some serial traffic reveals the protocol.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# read from 0x4000cf98
WRITE   80 40 00 cf 98  .@...
READ    00 00 00 00     ....
# write to 0x4000cf98
WRITE   c0 40 00 cf 98  .@...
WRITE   00 00 00 00     ....
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Some more investigation in the flash loader shows the low 6 bits of the first byte indicate the desired length of the transfer (in words), less 1, giving a maximum read size of 64 words or 256 bytes per read/write operation.&lt;/p&gt;
&lt;p&gt;I decided here to write a small shell to push the blob to the device then give an interface to issue arbitrary reads and writes. This ended up being quite useful later on when figuring out which hardware registers corresponded to the GPIO ports on the device, since it was trivial to write to suspect registers and observe the effect.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ # 800000a0 - direction, 800000ac - input, 800000b0 - output
$ python bootloader_shell.py bootloader_sequence.bin /dev/ttyS3
sending wakeup
sending bootloader payload
&amp;gt; w 800000a0 f0
wrote 800000a0 = 000000f0
&amp;gt; w 800000b0 f0
wrote 800000b0 = 000000f0
&amp;gt; r 800000ac
address 800000ac = 00 00 18 f0
&amp;gt; r 800000ac
address 800000ac = 00 00 1a f0
&amp;gt; r 800000ac
address 800000ac = 00 00 18 f0
&amp;gt; r 800000ac
address 800000ac = 00 00 1a f0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;There was one obvious target after disassembling some of the binaries extracted from the file system - extracting the internal ROM which contains a large portion of the device's code. The sheer amount of data stored in ROM is hinted at in the datasheet for the G2C547, a similar microcontroller for which a bare-bones preliminary datasheet is available.&lt;/p&gt;
&lt;p&gt;&lt;img alt="A screenshot of the G2M5477's datasheet, a related module, which reads &amp;quot;At the core of the module is the G2C547 SoC, which includes a SPARC v8 processor, and on-board ROM containing the eCos operating system, LWIP TCP/IP protocol suite, security software and hardware drivers.&amp;quot;" src="https://the6p4c.github.io/assets/rn-171/datasheet_rom.png"&gt;&lt;/p&gt;
&lt;p&gt;Having built a small shell came in handy here, as it was quite easy to add an extra command to dump a region of memory to a file without having to manually chunk the read into 256 byte blocks. Having disassembled a few of the binaries extracted from the file system, it was clear the internal ROM was stored beginning near the bottom of memory, and dumping 1 MiB of data from address 0 revealed the internal ROM without much effort.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ strings dump.bin | tail -n+41 | head -n20
/dev/ttydiag
/dev/haldiag
/dev/haldiag
haldiag_set_config
NVM config register
WARNING: nvm.bak not found
Reset Event
AO domain
ignored
Wdog reset
(0x%x)
We were asleep! 0x%x/%d
Wdog reset (%d)(%d) (tot:%d) @ 0x%x
Wdog Reset Event
Pstnt wdog2
Pstnt wdog
We were awake! 0x%x
INVALID!!!!
Checksum is %s
VALID
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h1&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;We'll leave it at that, though this device probably has plenty more secrets to reveal. Without an actual SDK in hand, the effort to reverse enough of the SDK functions to write an application myself would be monumental and probably not worth it. I learned enough in exploring the file system and prodding at the bootloader, so overall: time well spent.&lt;/p&gt;
&lt;p&gt;The tools I wrote during this are on &lt;a href="https://github.com/The6P4C/rn-171-tools"&gt;GitHub&lt;/a&gt;.&lt;/p&gt;</content><category term="blog"></category><category term="reverse engineering"></category><category term="embedded"></category></entry><entry><title>Reading CD subcode data</title><link href="https://the6p4c.github.io/2020/01/29/cd-subcode.html" rel="alternate"></link><published>2020-01-29T00:00:00+10:00</published><updated>2020-01-29T00:00:00+10:00</updated><author><name></name></author><id>tag:the6p4c.github.io,2020-01-29:/2020/01/29/cd-subcode.html</id><summary type="html">&lt;p&gt;DeviceIoControl as part of a healthy, balanced breakfast&lt;/p&gt;</summary><content type="html">&lt;p&gt;Thanks to &lt;a href="https://twitter.com/byuu_san"&gt;byuu&lt;/a&gt; for their &lt;a href="https://byuu.net/compact-discs/structure"&gt;article about CDs&lt;/a&gt;, and &lt;a href="https://twitter.com/TechConnectify"&gt;Technology Connections&lt;/a&gt; for his videos on &lt;a href="https://www.youtube.com/playlist?list=PLv0jwu7G_DFWBEyCKt4tKHIk8ez_pZS_P"&gt;digital audio/CDs&lt;/a&gt;. And even more videos about &lt;a href="https://www.youtube.com/watch?v=TCTWyNstpD0"&gt;CDs&lt;/a&gt;.&lt;/p&gt;
&lt;h1&gt;What's a subcode??&lt;/h1&gt;
&lt;p&gt;You probably realise CDs have more data on them than just audio if you've ever skipped to a specific track or been lucky enough to find a CD that has the artist name, album title, and track titles baked into it. Question is - where's all that data stored?&lt;/p&gt;
&lt;p&gt;It's probably simplest to consider a CD to be a list of sectors, with each sector containing 98 frames, with each frame containing 24 bytes of audio data, 8 bytes of ECC and most importantly, one subchannel byte. The presence and purpose of audio data and ECC is likely self-evident, but this one "subchannel" byte's may not be. Spoiler, that's where most of a CD's non-audio data is stored.&lt;/p&gt;
&lt;p&gt;Compared to the audio data, the subchannel is an extremely slow stream of data. When you realise we lose two of these subchannel bytes to special synchronisation values, and that the subchannel byte is essentially treated as 8 streams - one for each bit, labelled as P through W from MSB to LSB - it's clear there's not much capacity here. In some cases (like CD-TEXT, which gives you the artist name, album title, track titles, etc.) multiple subchannel bits from the same byte are used in conjunction with each other, but the P and Q channels are always used alone.&lt;/p&gt;
&lt;p&gt;These 96 extra bytes per frame are what we'll try and rip here.&lt;/p&gt;
&lt;h1&gt;Ripping subcode data&lt;/h1&gt;
&lt;p&gt;There's probably open-source software to do this. Maybe commercial software. Maybe I could have just right-clicked my CD drive and had Windows detect my goal and present me with a "Dump subcode data" menu item. But that's boring, so let's do it ourselves. Time to fire up Visual Studio and get a console app going.&lt;/p&gt;
&lt;p&gt;First we'll need a reference to the CD drive we're using. On my PC, my drive is assigned the drive letter &lt;code&gt;E&lt;/code&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;HANDLE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cdDrive&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;CreateFile&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="sa"&gt;L&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\\\\&lt;/span&gt;&lt;span class="s"&gt;.&lt;/span&gt;&lt;span class="se"&gt;\\&lt;/span&gt;&lt;span class="s"&gt;E:&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;GENERIC_READ&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;GENERIC_WRITE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;FILE_SHARE_READ&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;FILE_SHARE_WRITE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;OPEN_EXISTING&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Notice that the path we pass to &lt;code&gt;CreateFile&lt;/code&gt;, after stripping away the escaping, is &lt;code&gt;\\.\E:&lt;/code&gt;. Not &lt;code&gt;E:\&lt;/code&gt;, not &lt;code&gt;E:&lt;/code&gt;, but &lt;code&gt;\\.\E:&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Since our intention is to operate at a layer lower than the file system (our goal is to read some decently low-level data here), we need to avoid referencing any kind of construct that only makes in the context of a file system. That trailing slash we left off would signify "the root directory of drive E:" - exactly what we wanted to avoid. Leaving off the trailing slash points us to "the drive E itself" instead of "the root directory of the drive E". The &lt;code&gt;\\.\&lt;/code&gt; we've tacked on to the start signifies that the path is a &lt;a href="https://docs.microsoft.com/en-us/windows/win32/fileio/naming-a-file#win32-device-namespaces"&gt;"DOS device path"&lt;/a&gt; which further indicates that we're accessing a device, rather than a file. Simple, right?&lt;/p&gt;
&lt;p&gt;Now I'm not one for patience, and ripping a whole CD's worth of subcode data at 1x speed would take exactly as long as the CD itself, if not longer. We'll start our &lt;a href="https://docs.microsoft.com/en-us/windows/win32/api/ioapiset/nf-ioapiset-deviceiocontrol"&gt;&lt;code&gt;DeviceIoControl&lt;/code&gt;&lt;/a&gt; journey by telling the CD drive to ramp its speed up so we're not waiting around for the next half an hour.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;CDROM_SET_SPEED&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cdromSetSpeed&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;cdromSetSpeed&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;RequestType&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;CdromSetSpeed&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;cdromSetSpeed&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ReadSpeed&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0xFFFF&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// max speed&lt;/span&gt;
&lt;span class="n"&gt;cdromSetSpeed&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;WriteSpeed&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0xFFFF&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// max speed&lt;/span&gt;
&lt;span class="n"&gt;cdromSetSpeed&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;RotationControl&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;CdromDefaultRotation&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;DeviceIoControl&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;cdDrive&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;IOCTL_CDROM_SET_SPEED&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// Data in&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;cdromSetSpeed&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cdromSetSpeed&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// Data out&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;There's a bit to unpack here.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DeviceIoControl&lt;/code&gt; is the Windows API mechanism for communicating directly with a device driver - the equivalent of Linux's &lt;code&gt;ioctl&lt;/code&gt;. Since there's no file we can simply write to that tells the CD drive to change its speed, we've got to use this side-channel mechanism.&lt;/p&gt;
&lt;p&gt;First, we set up the data we'll send along with the request. Setting both the read and write speed to &lt;code&gt;0xFFFF&lt;/code&gt;, the maximum value for a &lt;code&gt;USHORT&lt;/code&gt;, commands the drive to use the maximum speed it's capable of. We also select the default rotation mode, CLV (constant linear velocity), though this isn't too important for our use.&lt;/p&gt;
&lt;p&gt;Setting the &lt;code&gt;RequestType&lt;/code&gt; member is quite important - &lt;code&gt;IOCTL_CDROM_SET_SPEED&lt;/code&gt; is used for both a &lt;code&gt;CDROM_SET_SPEED&lt;/code&gt; request (like we're sending) and a &lt;code&gt;CDROM_SET_STREAMING&lt;/code&gt; request. Both these structures begin with a &lt;code&gt;RequestType&lt;/code&gt; member, which the driver can use to distinguish the two.&lt;/p&gt;
&lt;p&gt;We then hand off this data structure to the driver by passing a pointer/length pair to &lt;code&gt;DeviceIoControl&lt;/code&gt;. We're not expecting a response, so we can zero the output arguments.&lt;/p&gt;
&lt;p&gt;We can actually check this out from the driver's side, by taking a look at some of the Windows driver samples. In the CD-ROM driver sample, we can see both the &lt;a href="https://github.com/microsoft/Windows-driver-samples/blob/master/storage/class/cdrom/src/cdrom.c#L3394"&gt;callback which handles all &lt;code&gt;IRP_MJ_DEVICE_CONTROL&lt;/code&gt; IRPs&lt;/a&gt; and the &lt;a href="https://github.com/microsoft/Windows-driver-samples/blob/master/storage/class/cdrom/src/ioctl.c#L9030"&gt;specific handler for an &lt;code&gt;IOCTL_CDROM_SET_SPEED&lt;/code&gt;&lt;/a&gt;. Side note - I don't recommend writing a Windows driver. Don't do it. It's not worth the suffering.&lt;/p&gt;
&lt;p&gt;That's it! CD drive speed set.&lt;/p&gt;
&lt;h2&gt;The easy way&lt;/h2&gt;
&lt;p&gt;There's a handy IOCTL for reading raw CD data, as you'd expect. Uncreatively named &lt;a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddcdrm/ni-ntddcdrm-ioctl_cdrom_raw_read"&gt;&lt;code&gt;IOCTL_CDROM_RAW_READ&lt;/code&gt;&lt;/a&gt;, we can ask the CD-ROM driver to read a number of sectors from a specified address in a specified format. Perfect!&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;ULONGLONG&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;sector&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;RAW_READ_INFO&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rawReadInfo&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;rawReadInfo&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DiskOffset&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;QuadPart&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;sector&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2048ULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;rawReadInfo&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SectorCount&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;rawReadInfo&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;TrackMode&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;RawWithSubCode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="kt"&gt;uint8_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;CD_RAW_SECTOR_WITH_SUBCODE_SIZE&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;DWORD&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bytesReturned&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;DeviceIoControl&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;cdDrive&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;IOCTL_CDROM_RAW_READ&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// Data in&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;rawReadInfo&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rawReadInfo&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// Data out&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;bytesReturned&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Eagle-eyed viewers (who've also been reading all the docs I've linked along the way 😋) may have noticed that the &lt;code&gt;2048ULL&lt;/code&gt; constant we use to turn our sector into an offset on the disk doesn't match the value of the &lt;code&gt;CD_RAW_SECTOR_WITH_SUBCODE_SIZE&lt;/code&gt; constant (&lt;code&gt;= 2352 + 96 = 2448&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;The CD-ROM driver tries to play it smart, and causes us a headache in the process.&lt;/p&gt;
&lt;p&gt;On a &lt;strong&gt;data&lt;/strong&gt; CD (remember, we're looking at Red Book Audio CDs here) each sector contains 2,048 bytes of data after the extra error correction is added on. Audio CDs contain 2,352 bytes of audio data, and we're requesting an extra 96 bytes of subcode data along side that. In an effort to make reading data CDs easier, the raw read IOCTL takes a disk offset in bytes rather than a LBA (logical block address) which would count from 0 for the first sector, incrementing by 1 for each subsequent sector. Since the CD drive has no concept of anything other than LBAs, the driver has to undo this multiplication by 2048 before it can pass it to the drive. Seriously. They also don't appear to check that the bits they throw away are zero, fun.&lt;/p&gt;
&lt;p&gt;From the CD-ROM driver sample, comments mine:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// In ioctl.c:RequestValidateReadWrite, one of many functions called before the&lt;/span&gt;
&lt;span class="c1"&gt;// IOCTL is handled&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;DeviceExtension&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;DiskGeometry&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;BytesPerSector&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;DeviceExtension&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;DiskGeometry&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;BytesPerSector&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2048&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;DeviceExtension&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;SectorShift&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;DeviceExtension&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;SectorShift&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;11&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// 2 to the power of 11 == 2048&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="c1"&gt;// Later on, inside ioctl.c:DeviceHandleRawRead&lt;/span&gt;
&lt;span class="c1"&gt;// Divide by 2048 with a shift&lt;/span&gt;
&lt;span class="n"&gt;startingSector&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ULONG&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;rawReadInfo&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DiskOffset&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;QuadPart&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;DeviceExtension&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;SectorShift&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="c1"&gt;// [...]&lt;/span&gt;
&lt;span class="n"&gt;cdb&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;READ_CD&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;StartingLBA&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;UCHAR&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;startingSector&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0xFF&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;cdb&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;READ_CD&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;StartingLBA&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;UCHAR&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;startingSector&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;cdb&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;READ_CD&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;StartingLBA&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;UCHAR&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;startingSector&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;cdb&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;READ_CD&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;StartingLBA&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;UCHAR&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;startingSector&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;24&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;With that aside, we set up the read, ask for the raw sector data including the subcode (there's no track mode for just subcode data 😢) and hand our request off to the driver. The driver does whatever it needs to do to perform that request, and hands the data back to us in our &lt;code&gt;data&lt;/code&gt; buffer, helpfully telling us how many bytes it read through the &lt;code&gt;bytesReturned&lt;/code&gt; value.&lt;/p&gt;
&lt;p&gt;Let's take a peek at the data it returned.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;00000000: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000010: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000020: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000030: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000040: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000050: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000060: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000070: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000080: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000090: 0000 0000 0000 0000 0000 0000 0000 0000  ................
000000a0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
000000b0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
000000c0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
000000d0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
000000e0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
000000f0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000100: 0000 0000 0000 0000 0000 0000 0000 0000  ................
            *** heaps more zeros ***
00000900: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000910: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000920: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000930: 8080 8080 8080 80c0 8080 8080 8080 80c0  ................
00000940: 8080 8080 8080 80c0 8080 8080 8080 8080  ................
00000950: 8080 8080 8080 8080 8080 8080 8080 8080  ................
00000960: 8080 8080 8080 8080 8080 8080 8080 8080  ................
00000970: 8080 8080 8080 c080 8080 8080 8080 8080  ................
00000980: 80c0 80c0 c080 c080 8080 c080 c080 8080  ................
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Bumping &lt;code&gt;sector&lt;/code&gt; up to 10 000 and we start to see some more data.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;00000000: 0df9 21f7 f9f6 9cf8 34f5 8afa a8f3 adfc  ..!.....4.......
00000010: 58f2 effe 75f1 6701 13f1 1804 49f1 fe06  X...u.g.....I...
00000020: f4f1 0a0a ddf2 e60c a6f3 1b0f 3af4 fc0f  ............:...
00000030: 88f4 610f 93f4 6c0d 5ff4 580a 0cf4 b006  ..a...l._.X.....
00000040: a8f3 dc02 29f3 cdfe 87f2 b1fa c5f1 8af6  ....)...........
00000050: cef0 26f2 e8ef afed 4cef 5ae9 35ef 3fe5  ..&amp;amp;.....L.Z.5.?.
00000060: bdef a2e1 44f1 c2de e1f3 1edd a3f7 f9dc  ....D...........
00000070: 4efc 64de 7e01 21e1 8f06 c8e4 de0a 9fe8  N.d.~.!.........
00000080: 630d c0eb ff0d c8ed 320c 68ee dd08 22ee  c.......2.h...&amp;quot;.
00000090: 8c04 98ed 1100 53ed defb 96ed 5bf8 7aee  ......S.....[.z.
000000a0: 8af5 8fef b2f3 bcf0 7af2 52f1 fff1 25f1  ........z.R...%.
000000b0: daf1 e3ef 4cf2 f8ed 39f3 d5eb 71f4 d4e9  ....L...9...q...
000000c0: f6f5 8ee8 aff7 64e8 52f9 6be9 a3fa cceb  ......d.R.k.....
000000d0: 5dfb f9ee 56fb 9ef2 6ffa 55f6 b5f8 8bf9  ]...V...o.U.....
000000e0: 30f6 8dfb 34f3 05fc 74f0 fefa 5aee dcf8  0...4...t...Z...
000000f0: 28ed 2cf6 36ed bff3 c2ee 85f2 8cf1 c7f2  (.,.6...........
00000100: 6bf5 8af4 fbf9 b2f7 9afe cdfb 6802 2600  k...........h.&amp;amp;.
            *** heaps more data ***
00000900: 1e0a a019 c70d 3b1d 8d0f 4b1f 150f 1a1f  ......;...K.....
00000910: f30b db1b 7906 6015 2eff 0d0c 05f7 c100  ....y.`.........
00000920: bcee a9f4 12e7 e5e8 a9e0 9cde eddb cad6  ................
00000930: 0000 0000 0000 0040 0000 0000 0000 0040  .......@.......@
00000940: 0000 0000 0000 0040 0000 0000 0000 4000  .......@......@.
00000950: 0000 0040 0000 4040 0000 4000 0040 0040  ...@..@@..@..@.@
00000960: 0000 0000 0000 0000 0000 0000 0000 4000  ..............@.
00000970: 0000 0040 0040 0040 0000 4000 0040 0040  ...@.@.@..@..@.@
00000980: 0040 0000 0040 0040 0000 0000 4040 4040  .@...@.@....@@@@
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Since we requested &lt;code&gt;RawWithSubCode&lt;/code&gt;, we see the CD digital audio data first, followed by our subcode data in the last 96 bytes (from 0x930 to 0x98F). Success!&lt;/p&gt;
&lt;h2&gt;The harder way&lt;/h2&gt;
&lt;p&gt;I originally abandoned the "easy" way because I thought this would give me access to the subcode data within the lead-in and lead-out. Turns out that's a "maybe", and things didn't really work out that way.&lt;/p&gt;
&lt;p&gt;We're already communicating directly with the driver, but the driver itself has to communicate with the drive somehow. After a couple layers of encapsulation (ATAPI, SATA) the driver is sending &lt;a href="https://en.wikipedia.org/wiki/SCSI"&gt;SCSI&lt;/a&gt; commands, specifically those from &lt;a href="http://www.13thmonkey.org/documentation/SCSI/mmc3r10g.pdf"&gt;SCSI MMC-3&lt;/a&gt; "Multimedia Commands".&lt;/p&gt;
&lt;p&gt;&lt;img alt="A screenshot from the SCSI MMC-3 standard showing the READ CD command structure" src="/assets/cd-subcode/scsi-mmc-3-read-cd.png"&gt;&lt;/p&gt;
&lt;p&gt;The raw SCSI READ CD command also gives us finer grain control of the data we receive back from the drive. If we don't set the "User Data" bit, we won't get any of the CDDA data - just the subcode data we originally wanted.&lt;/p&gt;
&lt;p&gt;More &lt;code&gt;DeviceIoControl&lt;/code&gt; magic now - with &lt;a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddscsi/ni-ntddscsi-ioctl_scsi_pass_through_direct"&gt;&lt;code&gt;IOCTL_SCSI_PASS_THROUGH_DIRECT&lt;/code&gt;&lt;/a&gt; we'll send a raw READ CD command to the drive.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// Earlier in our code...&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;read_cd&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;SCSI_PASS_THROUGH_DIRECT&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;scsiPassThrough&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;uint8_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;dataBuffer&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;96&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;uint8_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;senseBuffer&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;18&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="c1"&gt;// Send the actual command&lt;/span&gt;
&lt;span class="n"&gt;ULONGLONG&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;sector&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;read_cd&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;readCd&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;readCd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;scsiPassThrough&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Length&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;readCd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;scsiPassThrough&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;readCd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;scsiPassThrough&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ScsiStatus&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// Returned after command performed&lt;/span&gt;
&lt;span class="c1"&gt;// PathId, TargetId, Lun filled by port driver&lt;/span&gt;
&lt;span class="n"&gt;readCd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;scsiPassThrough&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CdbLength&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;11&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;readCd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;scsiPassThrough&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SenseInfoLength&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;18&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;readCd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;scsiPassThrough&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DataIn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;SCSI_IOCTL_DATA_IN&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;readCd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;scsiPassThrough&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DataTransferLength&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;96&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;readCd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;scsiPassThrough&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;TimeOutValue&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;readCd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;scsiPassThrough&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DataBuffer&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;readCd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dataBuffer&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;readCd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;scsiPassThrough&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SenseInfoOffset&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="kt"&gt;uint8_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;readCd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;senseBuffer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="kt"&gt;uint8_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;readCd&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="c1"&gt;// Operation code (READ CD)&lt;/span&gt;
&lt;span class="n"&gt;readCd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;scsiPassThrough&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Cdb&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0xBE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="c1"&gt;// Expected sector type (any type)&lt;/span&gt;
&lt;span class="n"&gt;readCd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;scsiPassThrough&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Cdb&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mb"&gt;0b000&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="c1"&gt;// Starting LBA (MSB to LSB)&lt;/span&gt;
&lt;span class="n"&gt;readCd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;scsiPassThrough&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Cdb&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sector&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;24&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0xFF&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;readCd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;scsiPassThrough&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Cdb&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sector&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0xFF&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;readCd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;scsiPassThrough&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Cdb&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sector&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0xFF&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;readCd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;scsiPassThrough&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Cdb&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;sector&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0xFF&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="c1"&gt;// Transfer length in blocks (MSB to LSB)&lt;/span&gt;
&lt;span class="n"&gt;readCd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;scsiPassThrough&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Cdb&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;readCd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;scsiPassThrough&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Cdb&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;readCd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;scsiPassThrough&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Cdb&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="c1"&gt;// Flag bits:&lt;/span&gt;
&lt;span class="c1"&gt;//     No sync field&lt;/span&gt;
&lt;span class="c1"&gt;//     No header codes&lt;/span&gt;
&lt;span class="c1"&gt;//     No user data&lt;/span&gt;
&lt;span class="c1"&gt;//     No EDC/ECC&lt;/span&gt;
&lt;span class="c1"&gt;//     No error data&lt;/span&gt;
&lt;span class="n"&gt;readCd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;scsiPassThrough&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Cdb&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mb"&gt;0b00&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mb"&gt;0b00&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="c1"&gt;// Sub-channel selection (raw)&lt;/span&gt;
&lt;span class="n"&gt;readCd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;scsiPassThrough&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Cdb&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mb"&gt;0b001&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;readCd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;scsiPassThrough&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Cdb&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;11&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;DWORD&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bytesReturned&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;DeviceIoControl&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;cdDrive&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;IOCTL_SCSI_PASS_THROUGH_DIRECT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// Data in&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;readCd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;readCd&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// Data out&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;readCd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;readCd&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;bytesReturned&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Uhh, what's with &lt;code&gt;struct read_cd&lt;/code&gt;? Doesn't the IOCTL just take a &lt;code&gt;SCSI_PASS_THROUGH_DIRECT&lt;/code&gt;. Well, yeah! That's why it's the first member of our struct. But you might have noticed the &lt;code&gt;SenseInfoOffset&lt;/code&gt; member inside the SCSI pass through structure. That member provides the driver an offset from the start of the &lt;code&gt;SCSI_PASS_THROUGH_DIRECT&lt;/code&gt; structure where a buffer for sense information is stored (consider it to be extended SCSI error information). Since it's unsigned, the sense buffer &lt;strong&gt;must&lt;/strong&gt; be after the SCSI pass through data in memory. Easiest way to ensure that is to put them both in the same structure, and pass them as one.&lt;/p&gt;
&lt;p&gt;The same logic applies for the data buffer, but only for &lt;a href="https://docs.microsoft.com/en-au/windows-hardware/drivers/ddi/ntddscsi/ns-ntddscsi-_scsi_pass_through"&gt;&lt;code&gt;SCSI_PASS_THROUGH&lt;/code&gt;&lt;/a&gt;. If we used that IOCTL instead, we'd also have to specify the data buffer as an offset.&lt;/p&gt;
&lt;p&gt;Now, for the original reason I wanted to issue a direct SCSI command, rather than going through the driver: this paragraph.&lt;/p&gt;
&lt;p&gt;&lt;img alt="A screenshot from the SCSI MMC-3 standard, which reads &amp;quot;When the Starting Logical Block Address is set to F000 0000h and P-W raw data is selected, the Logical Unit returns P-W raw data from the Lead-in area&amp;quot;" src="/assets/cd-subcode/scsi-mmc-3-read-cd-cd-text.png"&gt;&lt;/p&gt;
&lt;p&gt;But my hope was quickly dashed.&lt;/p&gt;
&lt;p&gt;&lt;img alt="A command line window showing a SCSI error. The corresponding error is highlighted in the MMC-3 spec - &amp;quot;Logical Block Address Out Of Range&amp;quot;" src="/assets/cd-subcode/lba-out-of-range.png"&gt;&lt;/p&gt;
&lt;p&gt;Apparently this isn't a widely supported feature. Oh well. We're not dragging along ~2 KiB of user data like we were with the raw read IOCTL, so this is probably faster anyway.&lt;/p&gt;
&lt;h1&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;There's not much to talk about once we've got the subcode data. Since we couldn't rip the lead-in, we can't access most CD-TEXT data (in raw form). I don't own any CD+Gs which store their graphics data in the R to to  W subchannels in the program area, so we're stuck. And honestly? This post is long enough as is.&lt;/p&gt;
&lt;p&gt;The Rust code I wrote to read the data we can from the Q subchannel (timecode, ISRC and catalogue number/barcode) can be found on &lt;a href="https://github.com/The6P4C/cd_subcode"&gt;GitHub&lt;/a&gt;. And you've basically read all the C code to rip the subchannel data here... just add some error checking and you're golden 😋&lt;/p&gt;</content><category term="blog"></category><category term="programming"></category></entry><entry><title>Investigating a firmware image and its compression</title><link href="https://the6p4c.github.io/2019/11/27/investigating-compression.html" rel="alternate"></link><published>2019-11-27T00:00:00+10:00</published><updated>2019-11-27T00:00:00+10:00</updated><author><name></name></author><id>tag:the6p4c.github.io,2019-11-27:/2019/11/27/investigating-compression.html</id><summary type="html">&lt;p&gt;From an opaque firmware image to disassembly in 3 easy steps.&lt;/p&gt;</summary><content type="html">&lt;p&gt;Downloading a firmware image and opening it up for the first time can be a great motivator - a list of bytes that somewhere hides executable code, just waiting to be analysed. Maybe you'll be the first person to have done so. Maybe you're the thousandth but you're up for a challenge.&lt;/p&gt;
&lt;p&gt;I'm sure there's two types of people - those who lose all hope when &lt;code&gt;binwalk&lt;/code&gt; doesn't spit out a single useful signature match, and those whose motivation to uncover the hidden secrets skyrockets. I'm not sure where I stand; it takes me a couple hours staring aimlessly at a hex editor, head-in-hands, for the motivation to completely fizzle.&lt;/p&gt;
&lt;p&gt;So with a firmware image acquired, I turned to &lt;code&gt;binwalk&lt;/code&gt; and &lt;code&gt;xxd&lt;/code&gt; for some light. Light that neither tool decided to shed onto the structure of the image.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Binwalk showing a false signature for a &amp;quot;MySQL ISAM index file&amp;quot; and a single copyright string. XXD is run on the file, which shows no discernible signature or structure to the file." src="/assets/investigating-compression/binwalk-xxd.png"&gt;&lt;/p&gt;
&lt;p&gt;That's alright - it doesn't take much to fool &lt;code&gt;binwalk&lt;/code&gt; into not displaying any matches. Let's employ another fun trick: converting our binary file into a PGM image (thanks &lt;a href="https://youtu.be/UTUYl-2g-r4?t=328"&gt;scanlime&lt;/a&gt;) to get an idea of how the file is structured. The &lt;code&gt;8600E134.dat&lt;/code&gt; file is 10,383,159 bytes long - just a few bytes more than a 512 pixel wide, 20,000 pixel tall, 1-byte-per-pixel image. That corresponds to a PGM header of &lt;code&gt;P5 512 20000 255\n&lt;/code&gt; which we'll prepend to the binary (&lt;a href="/assets/investigating-compression/pgm-trick-big.png"&gt;click here for a bigger, not truncated version&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;&lt;img alt="The PGM file shows a small section of noise/data, followed by a short section of white, a short section of noise/data, a very large section of noise/data, a large section of white, and a short section of noise/data." src="/assets/investigating-compression/pgm-trick.png"&gt;&lt;/p&gt;
&lt;p&gt;Looks like our file is actually a number of separate images, separated by large swaths of white &lt;code&gt;0xFF&lt;/code&gt; bytes. Not much use to us just yet.&lt;/p&gt;
&lt;p&gt;Can &lt;code&gt;strings&lt;/code&gt; give us a lead? If the file was simply a raw flash image that the processor loads and runs from 0, we'd expect to see the application's strings just sitting around in the binary. In this case since our binary starts with a very ASCII-looking string, there might be a header in the way, but that won't change the presence of raw strings further on in the file.&lt;/p&gt;
&lt;p&gt;Unsurprisingly, running &lt;code&gt;strings 8600E134.dat &amp;gt; 8600E134.dat.strings&lt;/code&gt; produces a 186,938 line file. Opening the listing in a text editor reveals something interesting however: not a single string of decent length was in one piece. Did we break &lt;code&gt;strings&lt;/code&gt;, or is something else going on?&lt;/p&gt;
&lt;p&gt;&lt;img alt="The strings file is open in Visual Studio Code, where the following lines (representing separate strings) are shown: &amp;quot;Updatin&amp;quot;, &amp;quot;g the fi&amp;quot;, &amp;quot;rmware i&amp;quot;, &amp;quot;s very r&amp;quot;, &amp;quot;isky. If&amp;quot;. This pattern of broken strings continues." src="/assets/investigating-compression/strings-output.png"&gt;&lt;/p&gt;
&lt;p&gt;In a hex editor, it's clear that &lt;code&gt;strings&lt;/code&gt; knew what it was doing. All of these strings are... odd. We've got enough of the string to work out what it once was, and the manual shows us what the original is. My "revelation" here may have already been spoiled for you, but see if you can spot what I eventually did.&lt;/p&gt;
&lt;p&gt;&lt;img alt="The raw firmware image is open in a hex editor, where the string snippets previously seen are visible. They are not null-terminated, and are broken up by single bytes and on occasion much longer sequences of bytes with unclear purpose." src="/assets/investigating-compression/hex-editor.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="The device's firmware update screen, which reads &amp;quot;Updating the firmware is very risky. If you make a mistake, the IC-R8600 may not operate properly, and repair at...&amp;quot; which continues for many more lines." src="/assets/investigating-compression/original-string.png"&gt;&lt;/p&gt;
&lt;p&gt;For a while, the entirely missing segments of the string baffled me. Where's the end of "mistake"? Where did the "ake" go? But with time, the revelation came - not more than 10 characters earlier did the string "ake" also occur. The "oper" of "properly"? Already there, at the start of "operate".&lt;/p&gt;
&lt;p&gt;We've got some kind of compression here.&lt;/p&gt;
&lt;h1&gt;Compression&lt;/h1&gt;
&lt;p&gt;Compression formats all operate on a shared principle - during compression, repetitive data can be replaced with some kind of marker which signals to the decompressor to stop, write out a sequence of bytes from some known source, and continue. Non-repetitive, or high entropy data can simply be stored as-is: no space savings can be found by replacing it with marker values, as at length it's probably unique within the file.&lt;/p&gt;
&lt;p&gt;Some compression formats utilise an explicit dictionary to perform this task - either running through the file before compression begins to find an optimal list of such repetitive byte sequences, or by progressively building a dictionary as compression is performed. In either case, the algorithm's marker values are simply a command to the decompressor to "grab the dictionary string at index &lt;code&gt;0x13&lt;/code&gt;," (for example) "and write it to the output".&lt;/p&gt;
&lt;p&gt;Markedly different are compression algorithms which utilise a sliding window. Rather than creating an explicit dictionary which maps indices to byte strings, marker values encode an offset from the current file position and a length: when a marker is encountered while decompressing, the decompressor seeks backwards by the offset value and copies the specified number of bytes from the already decompressed data into the output file.&lt;/p&gt;
&lt;p&gt;The missing repetitive values we see in our data are short, and when data is missing the block to be repeated occurs very close to the gap. Sounds like a sliding window algorithm, right? An explicit dictionary format probably wouldn't find adding a string as short as "ake" or "oper" to its dictionary as a smart (i.e. file-size reducing) move.&lt;/p&gt;
&lt;p&gt;Let's run with this hunch.&lt;/p&gt;
&lt;h1&gt;Our format&lt;/h1&gt;
&lt;p&gt;One thing you may have noticed in the hex view of the image was that every string of 8 literal characters (i.e. not compressed, and should be written directly to the decompressed file) was prefixed by an &lt;code&gt;0xFF&lt;/code&gt; byte.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# &lt;span class="o"&gt;^&lt;/span&gt; &lt;span class="nv"&gt;tons&lt;/span&gt; &lt;span class="nv"&gt;of&lt;/span&gt; &lt;span class="nv"&gt;bytes&lt;/span&gt; &lt;span class="nv"&gt;removed&lt;/span&gt;
&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="nv"&gt;F&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="nv"&gt;F&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="nv"&gt;F&lt;/span&gt; &lt;span class="mi"&gt;81&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="nv"&gt;F&lt;/span&gt; &lt;span class="mi"&gt;93&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="nv"&gt;F&lt;/span&gt; &lt;span class="nv"&gt;FE&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="nv"&gt;C&lt;/span&gt; &lt;span class="mi"&gt;75&lt;/span&gt; &lt;span class="mi"&gt;55&lt;/span&gt; &lt;span class="mi"&gt;70&lt;/span&gt; &lt;span class="mi"&gt;64&lt;/span&gt; &lt;span class="mi"&gt;61&lt;/span&gt; &lt;span class="mi"&gt;74&lt;/span&gt; &lt;span class="mi"&gt;69&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="nv"&gt;E&lt;/span&gt; # &lt;span class="nv"&gt;not&lt;/span&gt; &lt;span class="nv"&gt;sure&lt;/span&gt; &lt;span class="nv"&gt;what&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;&lt;span class="s"&gt;s going on here...&lt;/span&gt;
&lt;span class="nv"&gt;FF&lt;/span&gt; &lt;span class="mi"&gt;67&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt; &lt;span class="mi"&gt;74&lt;/span&gt; &lt;span class="mi"&gt;68&lt;/span&gt; &lt;span class="mi"&gt;65&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt; &lt;span class="mi"&gt;66&lt;/span&gt; &lt;span class="mi"&gt;69&lt;/span&gt; # &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="s"&gt;g the fi&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
&lt;span class="nv"&gt;FF&lt;/span&gt; &lt;span class="mi"&gt;72&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="nv"&gt;D&lt;/span&gt; &lt;span class="mi"&gt;77&lt;/span&gt; &lt;span class="mi"&gt;61&lt;/span&gt; &lt;span class="mi"&gt;72&lt;/span&gt; &lt;span class="mi"&gt;65&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt; &lt;span class="mi"&gt;69&lt;/span&gt; # &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="s"&gt;rmware i&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
&lt;span class="nv"&gt;FF&lt;/span&gt; &lt;span class="mi"&gt;73&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt; &lt;span class="mi"&gt;76&lt;/span&gt; &lt;span class="mi"&gt;65&lt;/span&gt; &lt;span class="mi"&gt;72&lt;/span&gt; &lt;span class="mi"&gt;79&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt; &lt;span class="mi"&gt;72&lt;/span&gt; # &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="s"&gt;s very r&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
&lt;span class="nv"&gt;FF&lt;/span&gt; &lt;span class="mi"&gt;69&lt;/span&gt; &lt;span class="mi"&gt;73&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="nv"&gt;B&lt;/span&gt; &lt;span class="mi"&gt;79&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="nv"&gt;E&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt; &lt;span class="mi"&gt;49&lt;/span&gt; &lt;span class="mi"&gt;66&lt;/span&gt; # &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="s"&gt;isky. If&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="nv"&gt;F&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt; &lt;span class="mi"&gt;79&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="nv"&gt;F&lt;/span&gt; &lt;span class="mi"&gt;75&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="nv"&gt;C&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="nv"&gt;F&lt;/span&gt; &lt;span class="nv"&gt;EA&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="nv"&gt;F&lt;/span&gt; &lt;span class="nv"&gt;FC&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="nv"&gt;F&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="nv"&gt;B&lt;/span&gt; &lt;span class="mi"&gt;94&lt;/span&gt; &lt;span class="nv"&gt;FF&lt;/span&gt; &lt;span class="mi"&gt;06&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="nv"&gt;D&lt;/span&gt; &lt;span class="mi"&gt;61&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="nv"&gt;B&lt;/span&gt; &lt;span class="mi"&gt;65&lt;/span&gt; # ...&lt;span class="nv"&gt;or&lt;/span&gt; &lt;span class="nv"&gt;here&lt;/span&gt;
# &lt;span class="nv"&gt;v&lt;/span&gt; &lt;span class="nv"&gt;tons&lt;/span&gt; &lt;span class="nv"&gt;of&lt;/span&gt; &lt;span class="nv"&gt;bytes&lt;/span&gt; &lt;span class="nv"&gt;removed&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;We can't just go searching through the file for &lt;code&gt;0xFF&lt;/code&gt; bytes, since when we don't know the entire plaintext we can't be 100% sure that the &lt;code&gt;0xFF&lt;/code&gt; byte we found isn't actually meant to end up in the plaintext. We can be 99.99% sure that in this case, our &lt;code&gt;0xFF&lt;/code&gt; byte is actually some kind of "8 literal bytes follow" marker, because we know the plaintext and no other interpretation would really make sense. We almost fall "out of sync" as soon as we hit a non-&lt;code&gt;0xFF&lt;/code&gt; byte after a &lt;code&gt;0xFF [8 literal byte]&lt;/code&gt; sequence, since we can't be sure what that next byte tells the decompressor to do. If we continue to go at this alone, without many, many hours of reverse engineering, we've kinda hit a dead end.&lt;/p&gt;
&lt;h1&gt;Final Fantasy VII, aka great LZSS documentation&lt;/h1&gt;
&lt;p&gt;I can't tell you how exactly I worked out what compression algorithm the firmware image used. To be honest, I think I stumbled upon some documentation and the Wikipedia article much earlier in the RE effort than I remember (after searching something like "0xFF 8 literal bytes"), but I wrote it off pretty quickly for some reason. I think it was partially due to misinterpreting the docs, but that's in the past now. Who knows.&lt;/p&gt;
&lt;p&gt;Turns out our compression is &lt;a href="https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Storer%E2%80%93Szymanski"&gt;LZSS&lt;/a&gt;, and our win comes in the form of &lt;a href="https://github.com/niemasd/PyFF7/wiki/LZSS-Format"&gt;documentation for the Final Fantasy VII data file format&lt;/a&gt;. Combined with &lt;a href="https://en.wikipedia.org/wiki/LZ77_and_LZ78#LZ77"&gt;Wikipedia's outline of LZ77&lt;/a&gt; (which utilises similar principles, and was helpful in understanding how the LZSS format operates), we've got enough to write our own decompressor.&lt;/p&gt;
&lt;p&gt;I'll "summarise" the LZSS format here.&lt;/p&gt;
&lt;p&gt;An LZSS compressed file is comprised of a header (4 bytes - simply the decompressed length of the file stored in little endian), followed by a series of blocks.&lt;/p&gt;
&lt;h2&gt;Blocks&lt;/h2&gt;
&lt;p&gt;Each block begins with a control byte, which dictates how the bytes which follow the control byte are to be interpreted. A control byte is always followed by 8 pieces of data (note: &lt;strong&gt;not necessarily&lt;/strong&gt; 8 bytes), which may each be either a literal byte (1 byte long), or a reference (2 bytes long).&lt;/p&gt;
&lt;p&gt;Each bit of the control byte defines what pieces of data are present after the control byte, with a 0 bit indicating a reference and a 1 bit indicating a literal. Bit 0, the least-significant bit, defines the piece of data which immediately follows the control byte. Bit 7, the most-significant bit, defines the piece of data which immediately precedes the next control byte.&lt;/p&gt;
&lt;p&gt;As each byte of the decompressed file is calculated, it is written to a circular buffer of length 4096 bytes. The first byte of the decompressed file is placed at index &lt;code&gt;0xFEE&lt;/code&gt; of the buffer, and the index incremented by one byte. Subsequent bytes are written at the current index, the index incremented, and the index wrapped around to 0 if it exceeds 4095 (the last position in the buffer).&lt;/p&gt;
&lt;p&gt;The buffer is initialised to all zeros.&lt;/p&gt;
&lt;div class="table-wrapper"&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Control byte&lt;/th&gt;
&lt;th&gt;Data&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;0xFF = 0b1111_1111&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;8 literals&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;0xFE = 0b1111_1110&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;1 reference, followed by 7 literals&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;0x7F = 0b0111_1111&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;7 literals, followed by 1 reference&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;0xE3 = 0b1110_0011&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;2 literals, followed by 3 references, followed by 3 literals&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;h2&gt;Literals&lt;/h2&gt;
&lt;p&gt;Literals are one byte in length, and as the name suggests - should be copied into the output file untouched.&lt;/p&gt;
&lt;h2&gt;References&lt;/h2&gt;
&lt;p&gt;A reference is two bytes in length, and encodes both a length and offset. The offset is &lt;em&gt;not&lt;/em&gt; relative to the current index, i.e. an index of &lt;code&gt;0x210&lt;/code&gt; is &lt;code&gt;0x210&lt;/code&gt; bytes from index 0 of the circular buffer. When encountered, the requested number of bytes should be copied from the circular buffer and into the output file, beginning at the requested offset into the buffer.&lt;/p&gt;
&lt;div class='table-wrapper'&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Byte&lt;/th&gt;
&lt;th colspan="8"&gt;&lt;code&gt;p&lt;/code&gt;&lt;/th&gt;
&lt;th colspan="8"&gt;&lt;code&gt;p+1&lt;/code&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;Bit&lt;/th&gt;
&lt;th&gt;7&lt;/th&gt;
&lt;th&gt;6&lt;/th&gt;
&lt;th&gt;5&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;0&lt;/th&gt;
&lt;th&gt;7&lt;/th&gt;
&lt;th&gt;6&lt;/th&gt;
&lt;th&gt;5&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;0&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Value&lt;/strong&gt;&lt;/td&gt;
&lt;td colspan="8"&gt;Offset (low byte)&lt;/td&gt;
&lt;td colspan="4"&gt;Offset (high nibble)&lt;/td&gt;
&lt;td colspan="4"&gt;Length (stored as &lt;code&gt;length - 3&lt;/code&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;Note: &lt;code&gt;offset = [high nibble] &amp;lt;&amp;lt; 8 | [low byte]&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The length of a reference is stored minus 3 as any reference which pulls in less than 3 bytes would take up less space if written as a pair of one or two literals. The data referenced by a length-offset pair can include data which has not yet been written to the file (i.e. offset 2, length 4) as - operating one byte at a time - the bytes which appeared to not yet exist are written before they are needed (Wikipedia explains this better).&lt;/p&gt;
&lt;h1&gt;Decompression&lt;/h1&gt;
&lt;p&gt;Before we can think about decompression, we must isolate the compressed block from the firmware. Recalling the &lt;code&gt;0xFF&lt;/code&gt;-delimited blocky structure of the image we saw earlier, if we work backwards from where we found our strings above, we can find the first couple non-&lt;code&gt;0xFF&lt;/code&gt; bytes of the block. They're more than likely the start of the block.&lt;/p&gt;
&lt;p&gt;&lt;img alt="The firmware image is open in a hex editor. 0xFF bytes are constant, until offset 0x10040, where actual data and a semi-ASCII string is visible." src="/assets/investigating-compression/block-start.png"&gt;&lt;/p&gt;
&lt;p&gt;The end of the block isn't as easy - we've got to be mindful that we're not 100% sure where the block ends (since the decompressed section could be end-padded with &lt;code&gt;0xFF&lt;/code&gt; which would look just like our filler data!) and so it's safer that we just chop the extra front-matter off instead. Our compression format stores the decompressed length, so we're unlikely to accidentally start attempting to decompress data that isn't actually compressed.&lt;/p&gt;
&lt;p&gt;We'll copy from the offset &lt;code&gt;0x10040&lt;/code&gt;, where the compressed data starts, to the end of the file. That becomes &lt;code&gt;compressed.bin&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;With all this information about the format and our compressed data, we can implement &lt;a href="https://gist.github.com/The6P4C/47736d332a64331e6358e1f67b3f43d2"&gt;a quick Python script to do our decompression&lt;/a&gt;. &lt;/p&gt;
&lt;p&gt;&lt;img alt="The Python decompression script is run on compressed.bin. XXD is then run on the decompressed output, showing the first 10 lines. A human readable string and patterns are noticeable in the output." src="/assets/investigating-compression/decompress.png"&gt;&lt;/p&gt;
&lt;p&gt;We have some known plaintext, so let's go looking:&lt;/p&gt;
&lt;p&gt;&lt;img alt="The strings command is run on the decompressed bin file and piped to grep which searches for the full string &amp;quot;Updating&amp;quot;. The output shows the original strings from the firmware update dialog, and more." src="/assets/investigating-compression/decompressed-strings.png"&gt;&lt;/p&gt;
&lt;p&gt;Much more like it :)&lt;/p&gt;
&lt;h1&gt;A retrospective&lt;/h1&gt;
&lt;p&gt;After I'd continued the RE process it turns out that this firmware image is (as suspected) simply written into on-board flash and executed from 0 (skipping &lt;code&gt;0x40&lt;/code&gt; bytes of header). The firmware's first step is to load a second stage from flash into RAM, which then loads the actual application into RAM by decompressing it with LZSS 🤦‍♀️&lt;/p&gt;
&lt;p&gt;My first step &lt;em&gt;could&lt;/em&gt; have been doing the research to find that the device runs on an ARM Cortex-A9, loading the image into a disassembler, seeing some plausible code and following the loading stages... but then, instead of trying to find a mystery compression algorithm I'd probably be staring at a bunch of machine code, trying to reverse engineer an algorithm I'd have assumed was proprietary or just obfuscation. It's easy to say in hindsight that this would have been a better route and "I totally would have realised it was a common algorithm!" but I don't think that's true. The only reason I was able to locate the decompression routine in the second stage was because I knew to look for the &lt;code&gt;0xFEE&lt;/code&gt; constant - information I wouldn't have known if I'd started from code.&lt;/p&gt;
&lt;p&gt;Lessons learned, if nothing else.&lt;/p&gt;</content><category term="blog"></category><category term="reverse engineering"></category></entry><entry><title>Learn about: Banker's Algorithm</title><link href="https://the6p4c.github.io/2019/11/12/learn-about-bankers-algorithm.html" rel="alternate"></link><published>2019-11-12T00:00:00+10:00</published><updated>2019-11-12T00:00:00+10:00</updated><author><name></name></author><id>tag:the6p4c.github.io,2019-11-12:/2019/11/12/learn-about-bankers-algorithm.html</id><summary type="html">&lt;p&gt;A practical understanding of the Banker's algorithm for deadlock detection and avoidance.&lt;/p&gt;</summary><content type="html">&lt;p&gt;In attempting to learn about it, I found there were two types of explanations of the Banker's algorithm - confusing pseudocode (not great when you're asked to do it by hand), and ones which failed to give any semblance of a "why". Sometimes both at once. So I opened Krita, and now there's this, which hopefully serves as a better teaching tool. Enjoy!&lt;/p&gt;
&lt;p&gt;I've also written a small tool which performs the Banker's algorithm, showing the steps along the way (&lt;a href="#tool"&gt;jump to the tool!&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Some details have been left out or simplified to emphasise the purpose above. Please tell me if there's something heinously wrong, though.&lt;/p&gt;
&lt;h1&gt;Explanation&lt;/h1&gt;
&lt;p&gt;&lt;img alt="Page 1" src="/assets/zines/bankers/bankers0.png"&gt;
&lt;img alt="Page 2" src="/assets/zines/bankers/bankers1.png"&gt;
&lt;img alt="Page 3" src="/assets/zines/bankers/bankers2.png"&gt;
&lt;img alt="Page 4" src="/assets/zines/bankers/bankers3.png"&gt;
&lt;img alt="Page 5" src="/assets/zines/bankers/bankers4.png"&gt;
&lt;img alt="Page 6" src="/assets/zines/bankers/bankers5.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="tool"&gt;&lt;/p&gt;
&lt;h1&gt;Visualisation Tool&lt;/h1&gt;
&lt;p&gt;&lt;/a&gt;&lt;/p&gt;
&lt;div id="bankers-tool"&gt;
    &lt;h2&gt;Inputs&lt;/h2&gt;
    &lt;div id="controls"&gt;
        &lt;div class="controls-row"&gt;
            &lt;button type="button" v-on:click="loadSafeExample"&gt;Safe example&lt;/button&gt;
            &lt;button type="button" v-on:click="loadUnsafeExample"&gt;Unsafe example&lt;/button&gt;
        &lt;/div&gt;
        &lt;div class="controls-row stretch"&gt;
            &lt;div&gt;
                &lt;label for="num-processes"&gt;Number of processes:&lt;/label&gt;
                &lt;input id="num-processes" type="number" min="2" max="10" v-model.number="numProcesses"&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="controls-row stretch"&gt;
            &lt;div&gt;
                &lt;label for="num-resources"&gt;Number of resources:&lt;/label&gt;
                &lt;input id="num-resources" type="number" min="1" max="10" v-model.number="numResources"&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="controls-row stretch"&gt;
            &lt;div class="stack"&gt;
                &lt;span&gt;ALLOCATION&lt;/span&gt;
                &lt;table class="matrix"&gt;
                    &lt;thead&gt;
                        &lt;tr&gt;
                            &lt;th scope="col"&gt;&lt;/th&gt;
                            &lt;th scope="col" v-for="resource in numResources"&gt;{{ resourceIdentifier(resource) }}&lt;/th&gt;
                        &lt;/tr&gt;
                    &lt;/thead&gt;
                    &lt;tbody&gt;
                        &lt;tr v-for="(row, process) in allocation"&gt;
                            &lt;th scope="row"&gt;P&lt;sub&gt;{{ process }}&lt;/sub&gt;&lt;/th&gt;
                            &lt;td v-for="(_, resource) in row"&gt;
                                &lt;input type="number" min="0" max="10" v-model.number="allocation[process][resource]"&gt;
                            &lt;/td&gt;
                        &lt;/tr&gt;
                    &lt;/tbody&gt;
                &lt;/table&gt;
            &lt;/div&gt;
            &lt;div class="stack"&gt;
                &lt;span&gt;MAX&lt;/span&gt;
                &lt;table class="matrix"&gt;
                    &lt;thead&gt;
                        &lt;tr&gt;
                            &lt;th scope="col"&gt;&lt;/th&gt;
                            &lt;th scope="col" v-for="resource in numResources"&gt;{{ resourceIdentifier(resource) }}&lt;/th&gt;
                        &lt;/tr&gt;
                    &lt;/thead&gt;
                    &lt;tbody&gt;
                        &lt;tr v-for="(row, process) in max"&gt;
                            &lt;th scope="row"&gt;P&lt;sub&gt;{{ process }}&lt;/sub&gt;&lt;/th&gt;
                            &lt;td v-for="(_, resource) in row"&gt;
                                &lt;input type="number" min="0" max="10" v-model.number="max[process][resource]"&gt;
                            &lt;/td&gt;
                        &lt;/tr&gt;
                    &lt;/tbody&gt;
                &lt;/table&gt;
            &lt;/div&gt;
            &lt;div class="stack"&gt;
                &lt;span&gt;AVAILABLE&lt;/span&gt;
                &lt;table&gt;
                    &lt;thead&gt;
                        &lt;tr&gt;
                            &lt;th v-for="resource in numResources"&gt;{{ resourceIdentifier(resource) }}&lt;/th&gt;
                        &lt;/tr&gt;
                    &lt;/thead&gt;
                    &lt;tbody&gt;
                        &lt;tr&gt;
                            &lt;td v-for="resource in numResources"&gt;
                                &lt;input type="number" min="0" max="10" v-model.number="available[resource - 1]"&gt;
                            &lt;/td&gt;
                        &lt;/tr&gt;
                    &lt;/tbody&gt;
                &lt;/table&gt;
            &lt;/div&gt;
            &lt;div v-if="result.type == 'success'" class="stack"&gt;
                &lt;span&gt;NEED (calculated)&lt;/span&gt;
                &lt;table class="matrix need"&gt;
                    &lt;thead&gt;
                        &lt;tr&gt;
                            &lt;th scope="col"&gt;&lt;/th&gt;
                            &lt;th scope="col" v-for="resource in numResources"&gt;{{ resourceIdentifier(resource) }}&lt;/th&gt;
                        &lt;/tr&gt;
                    &lt;/thead&gt;
                    &lt;tbody&gt;
                        &lt;tr v-for="(row, process) in result.need"&gt;
                            &lt;th scope="row"&gt;P&lt;sub&gt;{{ process }}&lt;/sub&gt;&lt;/th&gt;
                            &lt;td v-for="(cell, resource) in row"&gt;{{ cell }}&lt;/td&gt;
                        &lt;/tr&gt;
                    &lt;/tbody&gt;
                &lt;/table&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;h2&gt;Result (scroll along!)&lt;/h2&gt;
    &lt;div id="result-container"&gt;
        &lt;div id="result"&gt;
            &lt;p v-if="result.type == 'error'"&gt;
                &lt;template v-if="result.errorType == 'exceedMax'"&gt;
                    Error: process P&lt;sub&gt;{{ result.process }}&lt;/sub&gt; has exceeded its declared maximum of resource {{ resourceIdentifier(result.resource + 1) }}
                &lt;/template&gt;
                &lt;template v-else-if="result.errorType == 'maxTooBig'"&gt;
                    Error: process P&lt;sub&gt;{{ result.process }}&lt;/sub&gt; has declared a maximum of {{ result.maxWas }} instances of resource {{ resourceIdentifier(result.resource + 1) }}, however resource {{ resourceIdentifier(result.resource + 1) }} only has {{ result.resourceTotal }} instances total
                &lt;/template&gt;
                &lt;template v-else&gt;{{ error.message }}&lt;/template&gt;
            &lt;/p&gt;
            &lt;template v-if="result.type == 'success'"&gt;
                &lt;template v-for="step in result.trace"&gt;
                    &lt;svg v-if="needsStraightArrow(step)" version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg"&gt;
                        &lt;defs&gt;
                            &lt;marker id="arrow" viewBox="0 0 10 10" refX="10" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse"&gt;
                                &lt;path d="M 0 0 L 10 5 L 0 10 z" /&gt;
                            &lt;/marker&gt;
                        &lt;/defs&gt;
                        &lt;line x1="0%" y1="50%" x2="100%" y2="50%" stroke="black" stroke-width="2px" marker-end="url(#arrow)" /&gt;
                    &lt;/svg&gt;
                    &lt;svg v-if="needsSnakeArrow(step)" version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg"&gt;
                        &lt;defs&gt;
                            &lt;marker id="arrow" viewBox="0 0 10 10" refX="10" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse"&gt;
                                &lt;path d="M 0 0 L 10 5 L 0 10 z" /&gt;
                            &lt;/marker&gt;
                        &lt;/defs&gt;
                        &lt;line x1="0%" y1="90%" x2="50%" y2="90%" stroke="black" stroke-width="2px" /&gt;
                        &lt;line x1="50%" y1="90%" x2="50%" y2="50%" stroke="black" stroke-width="2px" /&gt;
                        &lt;line x1="50%" y1="50%" x2="100%" y2="50%" stroke="black" stroke-width="2px" marker-end="url(#arrow)" /&gt;
                    &lt;/svg&gt;
                    &lt;div v-if="step.type == 'available'" class="available"&gt;
                        &lt;div class="stack"&gt;
                            &lt;span&gt;AVAILABLE&lt;/span&gt;
                            &lt;table&gt;
                                &lt;thead&gt;
                                    &lt;tr&gt;
                                        &lt;th v-for="resource in numResources"&gt;{{ resourceIdentifier(resource) }}&lt;/th&gt;
                                    &lt;/tr&gt;
                                &lt;/thead&gt;
                                &lt;tbody&gt;
                                    &lt;tr&gt;
                                        &lt;td v-for="cell in step.available"&gt;{{ cell }}&lt;/td&gt;
                                    &lt;/tr&gt;
                                &lt;/tbody&gt;
                            &lt;/table&gt;
                        &lt;/div&gt;
                        &lt;div&gt;Processes remaining:&lt;/div&gt;
                        &lt;div v-if="step.processesRemaining.length != 0"&gt;
                            &lt;template v-for="(process, i) in step.processesRemaining"&gt;{{ i != 0 ? ", " : "" }}P&lt;sub&gt;{{ process }}&lt;/sub&gt;&lt;/template&gt;
                        &lt;/div&gt;
                        &lt;div v-else&gt;(none)&lt;/div&gt;
                    &lt;/div&gt;
                    &lt;div v-if="step.type == 'termination'" class="step"&gt;
                        &lt;p&gt;P&lt;sub&gt;{{ step.process }}&lt;/sub&gt; can run:&lt;/p&gt;
                        &lt;div class="calculation"&gt;
                            &lt;div class="stack lhs"&gt;
                                &lt;span class="value"&gt;{{ arrayString(step.need) }}&lt;/span&gt;
                                &lt;span class="label"&gt;P&lt;sub&gt;{{ step.process }}&lt;/sub&gt;'s NEED&lt;/span&gt;
                            &lt;/div&gt;
                            &lt;div class="operator"&gt;&amp;le;&lt;/div&gt;
                            &lt;div class="stack rhs"&gt;
                                &lt;span class="value"&gt;{{ arrayString(step.availableBeforeTermination) }}&lt;/span&gt;
                                &lt;span class="label"&gt;AVAILABLE&lt;/span&gt;
                            &lt;/div&gt;
                        &lt;/div&gt;
                        &lt;p&gt;P&lt;sub&gt;{{ step.process }}&lt;/sub&gt; terminates and frees its allocated resources:&lt;/p&gt;
                        &lt;div class="calculation"&gt;
                            &lt;div class="stack lhs"&gt;
                                &lt;span class="value"&gt;{{ arrayString(step.availableBeforeTermination) }}&lt;/span&gt;
                                &lt;span class="label"&gt;AVAILABLE&lt;/span&gt;
                            &lt;/div&gt;
                            &lt;div class="operator"&gt;+&lt;/div&gt;
                            &lt;div class="stack rhs"&gt;
                                &lt;span class="value"&gt;{{ arrayString(step.allocated) }}&lt;/span&gt;
                                &lt;span class="label"&gt;P&lt;sub&gt;{{ step.process }}&lt;/sub&gt;'s ALLOCATED&lt;/span&gt;
                            &lt;/div&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                    &lt;div v-if="step.type == 'result' &amp;&amp; step.isStateSafe" class="result safe"&gt;
                        &lt;p&gt;All processes can successfully acquire their maximum number of resources then terminate.&lt;/p&gt;
                        &lt;p&gt;Therefore, the system is in a &lt;strong&gt;safe state&lt;/strong&gt;.&lt;/p&gt;
                    &lt;/div&gt;
                    &lt;div v-if="step.type == 'result' &amp;&amp; !step.isStateSafe" class="result unsafe"&gt;
                        &lt;p&gt;No other process is able to acquire the resources it requires to terminate.&lt;/p&gt;
                        &lt;div v-for="process in step.processesRemaining" class="calculation"&gt;
                            &lt;div class="stack lhs"&gt;
                                &lt;span class="value"&gt;{{ arrayString(step.need[process]) }}&lt;/span&gt;
                                &lt;span class="label"&gt;P&lt;sub&gt;{{ process }}&lt;/sub&gt;'s NEED&lt;/span&gt;
                            &lt;/div&gt;
                            &lt;div class="operator"&gt;&amp;ge;&lt;/div&gt;
                            &lt;div class="stack rhs"&gt;
                                &lt;span class="value"&gt;{{ arrayString(step.available) }}&lt;/span&gt;
                                &lt;span class="label"&gt;AVAILABLE&lt;/span&gt;
                            &lt;/div&gt;
                        &lt;/div&gt;
                        &lt;p&gt;Therefore, the system is in an &lt;strong&gt;unsafe state&lt;/strong&gt; which may lead to deadlock.&lt;/p&gt;
                    &lt;/div&gt;
                &lt;/template&gt;
            &lt;/template&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;&lt;link rel="stylesheet" href="/assets/zines/bankers/bankers.css"&gt;&lt;/p&gt;
&lt;script src="https://cdn.jsdelivr.net/npm/vue@2.6.0"&gt;&lt;/script&gt;
&lt;script src="/assets/zines/bankers/bankers.js"&gt;&lt;/script&gt;</content><category term="zines"></category><category term="programming"></category><category term="computer science"></category></entry><entry><title>Quick RE: The Tandberg TT6120 'TS Processor'</title><link href="https://the6p4c.github.io/2018/11/11/quick-re-tandberg-tt6120.html" rel="alternate"></link><published>2018-11-11T00:00:00+10:00</published><updated>2018-11-11T00:00:00+10:00</updated><author><name></name></author><id>tag:the6p4c.github.io,2018-11-11:/2018/11/11/quick-re-tandberg-tt6120.html</id><summary type="html">&lt;p&gt;A quick reverse engineering of a 'Transport Stream Processor', used in TV and video production.&lt;/p&gt;</summary><content type="html">&lt;p&gt;This is the Tandberg (now owned by Ericsson) TT6120 TS Processor. Catchy name, I know. I picked it up at a hamfest recently, out of sheer interest regarding what it was and what was inside it.&lt;/p&gt;
&lt;p&gt;&lt;img alt="A front view of the Tandberg TT6120" src="/assets/quick-re-tandberg-tt6120/front-view.png"&gt;&lt;/p&gt;
&lt;p&gt;With a bit of Googling (and the help of an expert) I found out it's a "transport stream processor" - a device which takes in one source of video, and spits out another (possibly in a different format). In the device I picked up, a &lt;a href="https://en.wikipedia.org/wiki/Quadrature_amplitude_modulation"&gt;QAM&lt;/a&gt; (an RF modulation method) demodulator acts as one input, and an &lt;a href="https://en.wikipedia.org/wiki/Asynchronous_serial_interface"&gt;ASI&lt;/a&gt; (a serial video format) interface as the output.&lt;/p&gt;
&lt;p&gt;&lt;img alt="A rear view of the Tandberg TT6120, showing the QAM demodulator and 'TSP' with ASI in/out" src="/assets/quick-re-tandberg-tt6120/rear-view.png"&gt;&lt;/p&gt;
&lt;p&gt;It's quite a pretty device once you pop the lid off. The modular structure of the device hinted to by the handles and bolts on the rear of the device is confirmed - both blocks connect to a backplane with common connectors. Since many other input and output formats are supported by the device, it's a much cheaper solution than having to spin many different boards for each combination of input and output format.&lt;/p&gt;
&lt;p&gt;Pictured below is the QAM demod (left) and TSP (right) modules.&lt;/p&gt;
&lt;p&gt;&lt;img alt="The QAM demodulator and TSP modules" src="/assets/quick-re-tandberg-tt6120/inside-modules.png"&gt;&lt;/p&gt;
&lt;p&gt;The backplane connects to this small common board, which only has a single Lattice PLD, some power supply components and acts as an interface between the front panel LCD and buttons and the backplane.&lt;/p&gt;
&lt;p&gt;&lt;img alt="The common mainboard which connects to the backplane" src="/assets/quick-re-tandberg-tt6120/inside-common.png"&gt;&lt;/p&gt;
&lt;h1&gt;RF&lt;/h1&gt;
&lt;p&gt;The QAM demodulator module is intended to receive a DVB-C cable TV signal and extract the video data from it. The module has a tuner capable of receiving from 50 MHz to 860 MHz (producing an IF of 36.125 MHz), which is then fed into another mixer to bring this 1st IF to the 44 MHz 2nd IF frequency required by the QAM demodulator IC.&lt;/p&gt;
&lt;p&gt;&lt;img alt="The RF chain of the QAM demodulator" src="/assets/quick-re-tandberg-tt6120/rf-chain.png"&gt;&lt;/p&gt;
&lt;p&gt;Note: there's definitely something weird with this I don't understand. The LO of the dedicated mixer is a 28.636363 MHz crystal - but adding/subtracting ~28 MHz from the 36.125 MHz IF from the tuner gets you nowhere near the IF of the QAM demodulator IC - 44 MHz. However, 1/4 (or 1/3) of the crystal's frequency gets much closer to the demodulator's IF, though I know that doesn't make much sense (it's the closest I can get to understanding this though!). I'm not an RF expert so please, please - if you know how this is meant to work, do tell!&lt;/p&gt;
&lt;h1&gt;Embedded&lt;/h1&gt;
&lt;h2&gt;JTAG&lt;/h2&gt;
&lt;p&gt;Most of the processing power in the device is housed in the TSP module. On the board is a large Xilinx XCV300E FPGA and an Intel i960 embedded processor. Interestingly, under the serial port/alarm connector PCB, there's a lovely connector labelled "JTAG". With a bit of probing, it's not too hard to find the pinout of the connector.&lt;/p&gt;
&lt;p&gt;&lt;img alt="The JTAG header in the top left corner of the TSP board" src="/assets/quick-re-tandberg-tt6120/tsp-jtag.png"&gt;&lt;/p&gt;
&lt;p&gt;Identifying the GND pin is the easiest - check for continuity between the GND pin on basically any of the digital logic ICs and each of the pins on the JTAG header. Turns out it's pin 8 (numbering from pin 1, right-to-left, bottom-to-top in the perspective of the picture).&lt;/p&gt;
&lt;p&gt;Now, the JTAG signals of TCK, TMS, TDI and TDO can be found. TCK and TMS shouldn't be too hard - they're shared between every TAP in the scan chain, but TDI and TDO are chained through each device. Annoyingly, checking for continuity between the TCK pin on the i960 and each pin of the header gave no results. No pin of the header appeared to connect to the TCK pin of any of the 3 devices in the scan chain (Xilinx FPGA, Lattice PLD and the Intel i960) - and neither did the TMS pin.&lt;/p&gt;
&lt;p&gt;Testing the visible components around the JTAG header showed that most pins connected through a resistor to the small SOP-16 package IC below it. A single Google search later showed the part was a SN74LVTH125 bus buffer - but why's it there? As it turns out, each of the devices in the chain run on a 3V3 VCC, but the manufacturer clearly desired/only had hardware that would support a 5V JTAG interface. As such, the bus buffer acts as a level converter between the 3V3 logic on the board and the 5V signals of a JTAG adapter.&lt;/p&gt;
&lt;p&gt;&lt;img alt="How the bus buffer is used as a level converter" src="/assets/quick-re-tandberg-tt6120/level-converter.png"&gt;&lt;/p&gt;
&lt;p&gt;Now, it was clear that all four of the JTAG signals would pass through the bus buffer before making their way to the devices on the chain. Quickly the TCK and TMS pins were found to be 1 and 3 (respectively). Now comes identifying the TDO and TDI lines. Probing the TDO and TDI pins of the i960 showed no connection to the bus buffer, so it's clear it's in the middle of the scan chain. The TDO pin of the i960 did connect to the TDI pin of the Lattice iM4A PLD however, and tracing the PLD's TDI showed it eventually making connection to pin 5 of the JTAG header.&lt;/p&gt;
&lt;p&gt;Since it was now clear that the Xilinx FPGA was the first device in the scan chain, finding the TDO pin would be harder than the rest. As a big BGA device, there's no easy (and non-destructive) way to access the balls of the device, so simple continuity checking to find the pin was out of the question. Luckily, the pattern formed by the pins on the header seemed clear - TDI should logically appear on pin 7.&lt;/p&gt;
&lt;p&gt;So I connected my JTAG adapter (read: Altera USB Blaster clone), plugged the Tandberg in, and crossed my fingers.&lt;/p&gt;
&lt;p&gt;&lt;img alt="The Altera USB Blaster clone attached as a JTAG adapter" src="/assets/quick-re-tandberg-tt6120/jtag.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="OpenOCD showing the FPGA and PLD" src="/assets/quick-re-tandberg-tt6120/jtag-2.png"&gt;&lt;/p&gt;
&lt;p&gt;Hrm. Only two devices - the FPGA and PLD. Where's the i960?&lt;/p&gt;
&lt;p&gt;Darting to the &lt;a href="https://web.archive.org/web/20170225160554/http://download.intel.com/design/i960/datashts/27315906.pdf"&gt;i960's datasheet&lt;/a&gt;, the TRST# pin is immediately a possible culprit. When it's held low, the JTAG debug interface is disabled and is only enabled when the pin is high. A quick check with the multimeter shows the pin is always in a low state. Hmm.&lt;/p&gt;
&lt;p&gt;Tracing the pin's path on the PCB, again simply with my multimeter's continuity test, showed the pin driven by an output of the bus buffer with a pull-down resistor to ground. Easy - just drive the input to the buffer low (inverted output - driving the input low results in a high output) and the JTAG port will be enabled. Just one spanner in the works though: the input to the buffer is directly connected to VCC, so there's no way it can be pulled low. The input doesn't even appear on a pin on the JTAG connector.&lt;/p&gt;
&lt;p&gt;After a bit of head scratching (and random, uncoordinated continuity checking), I discovered the output enable pin (!) of the particular buffer outputting to the TRST# line was connected to the JTAG header. Pulled high with a 100 ohm resistor, it's as simple as pulling the OE line (pin 10 on the header) to ground. &lt;/p&gt;
&lt;p&gt;&lt;img alt="TRST#'s configuration through the bus buffer" src="/assets/quick-re-tandberg-tt6120/trst-oe.png"&gt;&lt;/p&gt;
&lt;p&gt;A link between the pin and a GND on another header later, and the full scan chain appears in all its glory.&lt;/p&gt;
&lt;p&gt;&lt;img alt="!TRST# pulled low" src="/assets/quick-re-tandberg-tt6120/jtag-with-gnd.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="OpenOCD showing the FPGA, PLD and i960" src="/assets/quick-re-tandberg-tt6120/jtag-3.png"&gt;&lt;/p&gt;
&lt;p&gt;Sadly though, with the age of the parts, the processor appears to only implement boundary scan and the PLD and FPGA are "sparse" in regards to the amount of information about them on the internet. A great sign of their age is the BFDL for the i960, which came in a self extracting EXE: not a Windows executable, but a DOS one. DOSBox to the rescue.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Extracting the i960 BFDL in DOSBox" src="/assets/quick-re-tandberg-tt6120/dosbox.png"&gt;&lt;/p&gt;
&lt;h2&gt;Serial&lt;/h2&gt;
&lt;p&gt;On the rear of the device, there's an RS-232 port which is "for service personnel only" according to the manual. I fancy myself as a bit of a service personnel anyway, so I thought I'd dig in.&lt;/p&gt;
&lt;p&gt;Thanks to the joyous non-standard nature of RS-232 serial ports, this took more effort than it needed to. Connecting to the serial port with the only female-female serial cable I could find gave no results, no matter the baud rate. Checking the TX line of the port on the scope showed some data bursts, but the USB-Serial adapter refused to communicate. Most likely an issue with either the port on the Tandberg or the cable I was using being wrong (i.e. the RX/TX flipped on the Tandberg, or my serial cable being something other than a null-modem cable), the next step was to try and swap the TX and RX lines to see if any data would appear.&lt;/p&gt;
&lt;p&gt;&lt;img alt="My poor-man's null-modem cable, joining the serial cable with the USB-Serial adapter" src="/assets/quick-re-tandberg-tt6120/null-modem.png"&gt;&lt;/p&gt;
&lt;p&gt;After building my poor-man's null-modem cable and fiddling with the baud rates, data finally poured through.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Boot-up sequence of the Tandberg" src="/assets/quick-re-tandberg-tt6120/serial.png"&gt;&lt;/p&gt;
&lt;p&gt;Mashing Enter brings us to a command line, with a couple interesting commands. &lt;code&gt;system&lt;/code&gt; gives us the information we've already seen at boot, but &lt;code&gt;ver&lt;/code&gt; gives us some stuff we haven't yet seen.&lt;/p&gt;
&lt;p&gt;&lt;img alt="The basic serial command line" src="/assets/quick-re-tandberg-tt6120/serial-simple.png"&gt;&lt;/p&gt;
&lt;p&gt;I kinda hoped there'd be a more interesting debug interface, so I started typing random commands until...&lt;/p&gt;
&lt;p&gt;&lt;img alt="Advanced command line after accidentally causing an NMI" src="/assets/quick-re-tandberg-tt6120/serial-nmi.png"&gt;&lt;/p&gt;
&lt;p&gt;Interesting! &lt;code&gt;db&lt;/code&gt; seems to read from memory somewhere, but given the address 500 (or any over 400 as it seems), causes an NMI that dumps us to a completely different prompt. What if we run &lt;code&gt;help&lt;/code&gt; from here?&lt;/p&gt;
&lt;p&gt;&lt;img alt="Advanced command line after accidentally causing an NMI" src="/assets/quick-re-tandberg-tt6120/serial-debug.png"&gt;&lt;/p&gt;
&lt;p&gt;Of course, I couldn't resist running half of these commands.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Running some of the commands in the debug/supervisor mode" src="/assets/quick-re-tandberg-tt6120/serial-debug-commands.png"&gt;&lt;/p&gt;
&lt;p&gt;Sadly, it seems pretty trigger-happy when it comes to firing random NMIs. I tried to dump the firmware using the &lt;code&gt;di&lt;/code&gt; command (both as one big block and as multiple blocks of ~256 bytes) but both approaches cause it to lock up part way through.&lt;/p&gt;
&lt;h1&gt;Summary&lt;/h1&gt;
&lt;p&gt;That's about it. It's an interesting box, and I can only imagine the shocking cost for each of these parts individually in this device's heyday - let alone how much it cost to buy new and the service contracts associated with it. Though I'm sure it served its owners well, &lt;/p&gt;
&lt;p&gt;If you've got any ideas on what to do with it (apart from throw it away 😂) I'd love to hear. The tuner is pretty cool - downconverting anything from 50 to 860 MHz down to around 30 MHz. Might be able to do something SDR-y with it? Trying to mess around with the FPGA and PLDs is probably a lost cause since I can't reverse engineer the bitstreams (let alone retrieve them from the devices anyway).&lt;/p&gt;
&lt;p&gt;Hope this was an interesting read.&lt;/p&gt;</content><category term="blog"></category><category term="reverse engineering"></category></entry><entry><title>Learn about: SPI</title><link href="https://the6p4c.github.io/2018/09/16/learn-about-spi.html" rel="alternate"></link><published>2018-09-16T00:00:00+10:00</published><updated>2018-09-16T00:00:00+10:00</updated><author><name></name></author><id>tag:the6p4c.github.io,2018-09-16:/2018/09/16/learn-about-spi.html</id><summary type="html">&lt;p&gt;A graphical introduction to SPI.&lt;/p&gt;</summary><content type="html">&lt;p&gt;Hey. Thanks to the helpful folks over on Reddit, I know this zine has a couple issues in the technical content (and some in the art, there's not meant to be two slave #2s!). I'd say it's still worth a read, but just be aware that I completely glossed over the full-duplex nature of SPI.&lt;/p&gt;
&lt;p&gt;Thanks for checking it out though - be on the look out for more of these with a bit more accuracy :)&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="/assets/zines/SPI.png"&gt;&lt;/p&gt;</content><category term="zines"></category><category term="electronics"></category></entry><entry><title>Hacking the fx-CP400 - Part 2.1 (Building a Cross-Compiler)</title><link href="https://the6p4c.github.io/2018/01/29/hacking-the-gc-part-2.1.html" rel="alternate"></link><published>2018-01-29T01:00:00+10:00</published><updated>2018-01-29T01:00:00+10:00</updated><author><name></name></author><id>tag:the6p4c.github.io,2018-01-29:/2018/01/29/hacking-the-gc-part-2.1.html</id><summary type="html">&lt;p&gt;Building a cross-compiler for the CASIO fx-CP400's SH4 processor.&lt;/p&gt;</summary><content type="html">&lt;p&gt;To be able to write code for the fx-CP400 without having to write machine code directly, we're going to need some type of assembler and/or compiler. Luckily for us, GCC has support for the SH4 architecture, so we don't have to write our own assembler or compiler. Compiling source code into machine code for an architecture other than the one the compiler is running on is known as cross-compilation. As such, we'll be building a cross-compiler for the SH4 architecture.&lt;/p&gt;
&lt;p&gt;Using the &lt;a href="https://wiki.osdev.org/GCC_Cross-Compiler"&gt;OSDev Wiki&lt;/a&gt; as "inspiration", here are the few simple steps to building a cross-compiler for the SH4 platform.&lt;/p&gt;
&lt;h1&gt;Setup&lt;/h1&gt;
&lt;p&gt;We'll define a few environment variables to ensure the process goes smoothly.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# folder to install our cross-compiler into&lt;/span&gt;
&lt;span class="nb"&gt;export&lt;/span&gt; &lt;span class="nv"&gt;PREFIX&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$HOME&lt;/span&gt;&lt;span class="s2"&gt;/opt/cross&amp;quot;&lt;/span&gt;

&lt;span class="c1"&gt;# the architecture and executable format we&amp;#39;re targeting&lt;/span&gt;
&lt;span class="nb"&gt;export&lt;/span&gt; &lt;span class="nv"&gt;TARGET&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;sh4-elf

&lt;span class="c1"&gt;# add the cross-compiler to our PATH&lt;/span&gt;
&lt;span class="c1"&gt;# you&amp;#39;ll probably want to put this somewhere like .bash-profile&lt;/span&gt;
&lt;span class="nb"&gt;export&lt;/span&gt; &lt;span class="nv"&gt;PATH&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$PREFIX&lt;/span&gt;&lt;span class="s2"&gt;/bin:&lt;/span&gt;&lt;span class="nv"&gt;$PATH&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h1&gt;Building binutils (&lt;code&gt;sh4-elf-as&lt;/code&gt;, &lt;code&gt;sh4-elf-objcopy&lt;/code&gt; and more)&lt;/h1&gt;
&lt;p&gt;Download the source code for Binutils from the &lt;a href="https://gnu.org/software/binutils/"&gt;Binutils website&lt;/a&gt;. Extract it into a directory, and &lt;code&gt;cd&lt;/code&gt; into the directory you've just extracted it into. Then, run these commands in that directory.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;mkdir build
&lt;span class="nb"&gt;cd&lt;/span&gt; build
../configure --target&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nv"&gt;$TARGET&lt;/span&gt; --prefix&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$PREFIX&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; --with-sysroot --disable-nls --disable-werror
make
make install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;You'll now have tools such as &lt;code&gt;sh4-elf-as&lt;/code&gt; and &lt;code&gt;sh4-elf-objcopy&lt;/code&gt; available.&lt;/p&gt;
&lt;h1&gt;Building gcc (&lt;code&gt;sh4-elf-gcc&lt;/code&gt;)&lt;/h1&gt;
&lt;p&gt;Download the source code for GCC from the &lt;a href="https://gnu.org/software/gcc/"&gt;GCC website&lt;/a&gt;. Extract it into a directory, and &lt;code&gt;cd&lt;/code&gt; into the directory you've just extracted it into. Then, run these commands in that directory. Be warned - the &lt;code&gt;make&lt;/code&gt; commands may take a long time, depending on your system and the &lt;code&gt;contrib/download_prerequisites&lt;/code&gt; will download about 30 MB of archives.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;contrib/download_prerequisites
mkdir build
&lt;span class="nb"&gt;cd&lt;/span&gt; build
../configure --target&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nv"&gt;$TARGET&lt;/span&gt; --prefix&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$PREFIX&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; --disable-nls --enable-languages&lt;span class="o"&gt;=&lt;/span&gt;c,c++ --without-headers
make all-gcc
make all-target-libgcc
make install-gcc
make install-target-libgcc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;You'll now have &lt;code&gt;sh4-elf-gcc&lt;/code&gt; availiable for your usage.&lt;/p&gt;</content><category term="blog"></category><category term="reverse engineering"></category></entry><entry><title>Hacking the fx-CP400 - Part 2 (Exploring the Firmware)</title><link href="https://the6p4c.github.io/2018/01/29/hacking-the-gc-part-2.html" rel="alternate"></link><published>2018-01-29T00:00:00+10:00</published><updated>2018-01-29T00:00:00+10:00</updated><author><name></name></author><id>tag:the6p4c.github.io,2018-01-29:/2018/01/29/hacking-the-gc-part-2.html</id><summary type="html">&lt;p&gt;Modifying the calculator's firmware by inserting a small test payload.&lt;/p&gt;</summary><content type="html">&lt;p&gt;After extracting the calculator's firmware from the updater in &lt;a href="https://the6p4c.github.io/2018/01/15/hacking-the-gc-part-1.html"&gt;Part 1&lt;/a&gt;, we can get finally down to details and see what this device can actually do. If you're interested in Windows reversing and haven't read Part 1 already, check it out!&lt;/p&gt;
&lt;p&gt;After extracting the firmware images, we're left with two binary files that don't have much meaning yet. They're full of compiled machine code, and we've got to disassemble the files to make any sense of them. Our first step in disassembling the files is to identify the processor, so our decompiler (IDA) knows how to turn our binary files into readable assembly.&lt;/p&gt;
&lt;p&gt;We'll only be dealing with the 3070 firmware image throughout this post, as it's the main software for the calculator. I'm also not too enthusiastic about bricking my calculator, which could be easy to do if I messed around with the bootloader firmware (3069) too much.&lt;/p&gt;
&lt;h1&gt;Identifying the processor&lt;/h1&gt;
&lt;p&gt;When I first started this project, this took me longer than I care to admit. Looking at pictures of the calculator's PCB shows no identifying marks - the main CPU is a epoxy-covered COB (chip on board) with no etchings or other markings. Unsurprisingly, the CASIO website gives no information in this regard, and simply searching "fx-CP400 processor" on Google brings up no useful hits.&lt;/p&gt;
&lt;p&gt;Searching the web now, I can easily find many resources that point to the Renesas SuperH (specifically, SH4) architecture used by the calculator &lt;a href="https://www.cncalc.org/assets/cp400.htm"&gt;[1]&lt;/a&gt; &lt;a href="https://en.wikipedia.org/wiki/Casio_ClassPad_300#fx-CP400"&gt;[2]&lt;/a&gt;. Since I'm not sure how I originally discovered the calculator used an SH4 processor, I'll just speculate on how I may have. Luckily, the fx-CP400 has many similar models and a well-documented predecessor, the ClassPad 330. This device is known to use a SH3 processor. I may have used this information to start searching for "fx-CP400 SuperH" and found one of the pages I linked above. This is a good strategy if you're completely unsure about the processor of the device you're handling - find older predecessors that may be better documented, or very similar products. They can give you a starting point that may lead you to wealths of helpful information.&lt;/p&gt;
&lt;p&gt;Now that we know the processor type, we can start loading our binary into IDA. It initially tries to tell us our file is a SNES ROM running on a MetaPC (left), but we correct it by loading as a binary file and setting the processor type to the Renesas SH4 (right).&lt;/p&gt;
&lt;p&gt;&lt;img alt="Loading the 3070 firmware file into IDA, and setting the file and processor type" src="/assets/hacking-the-gc-part-2/load-3070.png"&gt;&lt;/p&gt;
&lt;p&gt;Now, IDA asks us about the memory regions we want to set up. Since we're loading a simple binary file, IDA doesn't know where the data we're giving it ends up in memory. When you open a compiled ELF or PE file, a header inside the file gives the operating system and decompiler information about where each section of the file should be loaded in memory. Since all we've got is a binary blob that's dumped directly into the calculator's ROM, we've got to manually tell IDA where it all goes.&lt;/p&gt;
&lt;p&gt;Identifying the length of our RAM section isn't too hard - referring to the &lt;a href="https://www.omnimaga.org/news/classpad-ii-fx-cp400-hardware-a-hidden-sd-card-reader/"&gt;forum post&lt;/a&gt; found in Part 1, we know the RAM IC in the calculator is an M12L128168A. Searching for the part's datasheet, we find it can hold 134,217,728 bits, or &lt;code&gt;0x1000000&lt;/code&gt; bytes. We don't know the length of the ROM for sure yet, but it's safe enough to just use the length of the firmware file we have. Since the NAND flash is also used for the calculator's FAT filesystem and MCS, the ROM will certainly be larger than &lt;code&gt;0x1500000&lt;/code&gt; bytes, but that won't matter for now. &lt;a href="http://www.casiopeia.net/forum/viewtopic.php?t=1783"&gt;More research&lt;/a&gt; reveals RAM likely starts at &lt;code&gt;0x8C000000&lt;/code&gt;, and &lt;a href="http://prizm.cemetech.net/index.php/Flash"&gt;even more research&lt;/a&gt; shows ROM likely starts at &lt;code&gt;0x80000000&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Datasheet for the M12L128168A, showing its 134,217,728 bit storage space" src="/assets/hacking-the-gc-part-2/ram-datasheet.png"&gt;&lt;/p&gt;
&lt;p&gt;Even if we got these addresses slightly wrong, we'd find out quickly enough. When IDA attempts to &lt;a href="https://youtu.be/UTUYl-2g-r4?t=8m30s"&gt;mercilessly cross-reference&lt;/a&gt; our binary, any issues would become obvious. So, let's set up our memory.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Configuring IDAs knowledge of the memory" src="/assets/hacking-the-gc-part-2/configure-memory.png"&gt;&lt;/p&gt;
&lt;p&gt;IDA then asks us to choose exactly which SH4 device the code we're disassembling is for. Problem is: our specific SH4 processor is a custom model made for CASIO, that's not publicly documented at all. We're lucky, however, that these options basically only affect the labels IDA places on some memory addresses representing MSRs (model specific registers) to identify them. We'll just pick the first one and start the disassembly.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Selecting the SH7055" src="/assets/hacking-the-gc-part-2/select-device.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="IDA's initial disassembly of the firmware file" src="/assets/hacking-the-gc-part-2/initial-disassembly.png"&gt;&lt;/p&gt;
&lt;h1&gt;Exploring the firmware&lt;/h1&gt;
&lt;p&gt;Now comes the time we've got to discuss the SuperH architecture used by the fx-CP400. There are a few quirks which, unless you've worked with SuperH before, won't be obvious at all. There are 16 general purpose registers, &lt;code&gt;r0&lt;/code&gt; to &lt;code&gt;r15&lt;/code&gt;. Registers &lt;code&gt;r0&lt;/code&gt; to &lt;code&gt;r7&lt;/code&gt; are not required to be preserved through function calls, but &lt;code&gt;r8&lt;/code&gt; to &lt;code&gt;r15&lt;/code&gt; are. The register &lt;code&gt;r15&lt;/code&gt; is used as the stack pointer. The calling convention used is quite simple - arguments are passed in registers &lt;code&gt;r4&lt;/code&gt; to &lt;code&gt;r7&lt;/code&gt; and then on the stack if registers run out. Return values are passed back in the &lt;code&gt;r0&lt;/code&gt; register.&lt;/p&gt;
&lt;p&gt;The processor also makes use of what's known as a &lt;a href="https://en.wikipedia.org/wiki/Delay_slot"&gt;delay slot&lt;/a&gt;. After most branches, the instruction directly following the branch instruction is executed before the branch is or isn't taken. Take the following two pieces of assembly for example.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# 1
mov #1, r4
mov #2, r5
call my_function
mov #3, r6

# 2
bt my_label # conditional jump
mov #1, r4
my_label:
mov #2, r5
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;In the first code sample, the instruction moving 3 into &lt;code&gt;r6&lt;/code&gt; will be run before the call. In &lt;code&gt;my_function&lt;/code&gt;, the value of &lt;code&gt;r6&lt;/code&gt; would be 3. In the second code sample, the &lt;code&gt;mov #1, r4&lt;/code&gt; instruction will be run, no matter the outcome of the conditional branch. No matter if the jump is or isn't taken, the delay slot instruction will be run. Keep this in mind - it's a gotcha that can make a simple function seem a lot more confusing than it actually is. With that out of the way, let's finally look at the firmware.&lt;/p&gt;
&lt;p&gt;Considering the complexity of the device we've got in our hands, starting our investigation at the very start of the firmware image isn't the best idea. It's likely that there'll be enough complicated setup and initialization (the LCD, the keypad, the flash, etc.) that we could very easily get lost and never actually reach anything interesting. So to begin, let's start with a place in the code we know will exist. In Part 1, we quickly discussed the debugging menu reachable by holding &lt;code&gt;[=]&lt;/code&gt; and &lt;code&gt;[EXP]&lt;/code&gt; and turning the GC on. Mashing &lt;code&gt;[LEFT]&lt;/code&gt; and &lt;code&gt;[z]&lt;/code&gt; brings us to a selection menu.&lt;/p&gt;
&lt;p&gt;&lt;img alt="The debug menu" src="/assets/hacking-the-gc-part-2/debug-menu.jpg"&gt;&lt;/p&gt;
&lt;p&gt;We'll use the strings we see in the the debug selection menu to break into the firmware. The goal here is to discover how the menu is drawn to the screen, and hopefully write our own text onto the display at some point. We'll open the Strings window in IDA, and search for the string &lt;code&gt;TEST MENU&lt;/code&gt;, from the first menu option on the mode selection screen. We're presented with a ton of strings, but the first result matches the menu item exactly. Double clicking the string in the window takes us to the location it's stored in the firmware, and checking the cross references shows two locations the string is referenced.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Searching for TEST MENU in the Strings window" src="/assets/hacking-the-gc-part-2/string-search.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="Cross references to the 1.TEST MENU string" src="/assets/hacking-the-gc-part-2/string-xrefs.png"&gt;&lt;/p&gt;
&lt;p&gt;The first reference we see (in a &lt;code&gt;mov&lt;/code&gt; instruction) is the true use of the string. The second reference (in a &lt;code&gt;.data.l&lt;/code&gt; directive) is storing the address of the string in a constant pool after the function it's used in. Since instructions on the SH4 platform are constant length, it's not possible to store a whole address within the instruction and instead the full value must be placed in another memory location within reach of the instruction. Thankfully, IDA makes the usage of a constant pool transparent to us, and simply shows the &lt;code&gt;mov&lt;/code&gt; instruction moving the address of the string into the &lt;code&gt;r4&lt;/code&gt; register.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Disassembly of the function which references the 1.TEST MENU string" src="/assets/hacking-the-gc-part-2/select-mode-disassembly.png"&gt;&lt;/p&gt;
&lt;p&gt;To make our lives easier later on, we'll name the function we're looking at something that'll help us keep track of it. For these functions used in the debug menus, I've utilized the prefix &lt;code&gt;Debug_&lt;/code&gt; to differentiate them from those in the main OS. I've called this function &lt;code&gt;Debug_SelectMode1&lt;/code&gt; (because I know there's a second screen with &lt;code&gt;SELECT MODE&lt;/code&gt; on it!).&lt;/p&gt;
&lt;p&gt;Luckily for us, there are multiple strings printed here. This makes it a lot easier to confirm that the functions we find actually do what we think they do. Looking at how each string is used, we see that the string's address is loaded into &lt;code&gt;r4&lt;/code&gt; and then the function address stored in &lt;code&gt;r14&lt;/code&gt; is called (&lt;code&gt;jsr&lt;/code&gt; jumps to a subroutine, &lt;code&gt;jsr @r14&lt;/code&gt; jumps to a subroutine whose address is in &lt;code&gt;r14&lt;/code&gt;). In the delay slot, the value 0 is placed into &lt;code&gt;r5&lt;/code&gt;. This shows us there's probably only two arguments to the function - the string and an unknown second argument. Since it clearly prints the string it's given, we'll rename the function loaded into &lt;code&gt;r14&lt;/code&gt; from &lt;code&gt;sub_8002DA0C&lt;/code&gt; to &lt;code&gt;Debug_PrintString&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Interleaved throughout the &lt;code&gt;Debug_PrintString&lt;/code&gt; calls, is a call to another function &lt;code&gt;sub_8002E430&lt;/code&gt;. If we examine the arguments passed in to the function, we start to notice a pattern.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;r4 = 0      r5 = 0
r4 = 1      r5 = 2
r4 = 1      r5 = 4
r4 = 1      r5 = 6
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Before the first string is printed, the function is called with the arguments 0 and 0. As the next three strings are printed, the first argument is always 1 whilst the second argument increases by 2. Looking back at the debug screen, we notice each of the menu options is displayed with a one line gap between each. Counting characters, we notice the arguments to the function coincide with the position the string is printed. We've discovered the function used to set the position of the cursor, so let's call it &lt;code&gt;Debug_SetCursorPosition&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;We've now identified almost all the functions used in this small section of code. There's one function we haven't found, whose existence isn't necessarily obvious. This is a function which displays the changes we've made to the screen, equivalent to a swapping buffers in a more sophisticated graphical application. There are two function calls which immediately follow our cursor position setting and string printing functions.&lt;/p&gt;
&lt;p&gt;Inspecting the first function, &lt;code&gt;sub_8006317&lt;/code&gt;, shows it makes many calls to the &lt;code&gt;Debug_PrintString&lt;/code&gt; function with some strings we can recognize from the debug menu. It's unlikely this is our drawing function. The next function (&lt;code&gt;sub_8003733E&lt;/code&gt;), however, calls directly to another function which calls &lt;em&gt;another&lt;/em&gt; function. After traversing the maze, we're shown a function (&lt;code&gt;loc_800372EE&lt;/code&gt;) which looks quite unremarkable. This is likely our screen drawing function. To confirm, we can look at other locations where the &lt;code&gt;Debug_PrintString&lt;/code&gt; function is used, and check if our newly identified function is used there as well.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Identifying the Debug_DrawScreen function" src="/assets/hacking-the-gc-part-2/drawscreen-function.png"&gt;&lt;/p&gt;
&lt;p&gt;Since we're now pretty sure &lt;code&gt;sub_8003733E&lt;/code&gt; is our screen drawing function, we'll rename it to &lt;code&gt;Debug_DrawScreen&lt;/code&gt;. Our initial section of code, &lt;code&gt;Debug_SelectMode1&lt;/code&gt; now looks like this.&lt;/p&gt;
&lt;p&gt;&lt;img alt="The Debug_SelectMode1 function, with discovered functions renamed" src="/assets/hacking-the-gc-part-2/disassembled-debug-selectmode1.png"&gt;&lt;/p&gt;
&lt;p&gt;Let's write a short snippet of code to test the functions we've discovered. This is the step we're going to need our SH4 cross-compiler for. If you'd like to know how to build a cross-compiler for SH4 yourself, check out &lt;a href="https://the6p4c.github.io/2018/01/29/hacking-the-gc-part-2.1.html"&gt;Part 2.1&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Since they're annoying to deal with, we'll place &lt;code&gt;nop&lt;/code&gt; instructions in every delay slot to avoid them. &lt;a href="https://gist.github.com/The6P4C/6ba6bf2461a1215d94e7ba54d1a2a8c3#file-main-s"&gt;This&lt;/a&gt; is a Gist with the assembly code we've written to test these functions. It's thoroughly commented, so even if you're not familiar with SH4 assembler you'll probably understand it.&lt;/p&gt;
&lt;p&gt;We'll save this file as &lt;code&gt;main.s&lt;/code&gt; and compile the code into a flat binary, ready to be copied into some location within the firmware.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sh4-elf-as main.s -o main.o
sh4-elf-objcopy -O binary main.o main.bin
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The file &lt;code&gt;main.bin&lt;/code&gt; is then ready to be inserted into the firmware. The location where we do this is important to determine. We can't just paste it at the first address in the firmware, as we'd overwrite vital initialization code and could possibly even brick the device. We've got to find a location where we can control execution, i.e a piece of code we can trigger when we want. We find that we can make a "Check" button appear within the language selection dialog in the System app, when the debug mode is enabled. This debug mode can be triggered through the debug menu. &lt;/p&gt;
&lt;p&gt;&lt;img alt="The Check button within the language selector within the System application" src="/assets/hacking-the-gc-part-2/check-button.png"&gt;&lt;/p&gt;
&lt;p&gt;We'll do a search for one of the strings that appears within the Check menu and place our code there. This location ends up being &lt;code&gt;0x80133144&lt;/code&gt;, which is the location &lt;code&gt;0x133144&lt;/code&gt; within our firmware image. Since our code will halt once it's finished, we don't have to worry about returning from the function we're overwriting. We open the 3070 firmware file with a hex editor, and copy the bytes from our generated &lt;code&gt;main.bin&lt;/code&gt; file into the firmware file at the address &lt;code&gt;0x133144&lt;/code&gt;. We must ensure we're overwriting the bytes within the firmware file, rather than inserting our code and displacing the bytes that follow.&lt;/p&gt;
&lt;p&gt;&lt;img alt="The 3070 firmware file, with our code overwriting the function for the Check button" src="/assets/hacking-the-gc-part-2/code-inserted.png"&gt;&lt;/p&gt;
&lt;p&gt;Using a &lt;a href="https://gist.github.com/The6P4C/6ba6bf2461a1215d94e7ba54d1a2a8c3#file-fw_pack-py"&gt;short Python script&lt;/a&gt;, we compress the firmware file in the same way as seen in the &lt;code&gt;OSupdateDLL.dll&lt;/code&gt; file. Taking care to ensure the missing byte reported by the tool is the same as the one which is hardcoded into the DLL, we embed it back into the DLL file using a resource editor.&lt;/p&gt;
&lt;p&gt;With the modified &lt;code&gt;OSupdateDLL.dll&lt;/code&gt; and original &lt;code&gt;fxASPI.dll&lt;/code&gt; and &lt;code&gt;LanguageResource.dll&lt;/code&gt; files in one directory, we can run the updater. Running the command &lt;code&gt;rundll32 OSUpdateDLL.dll,OSUpdate&lt;/code&gt; launches the firmware updater and we're almost ready to flash. Since the version of firmware we're attempting to write into the calculator is the same as the one which is running on it, simply using the OS Update menu option within the Communication app won't work. We must launch the calculator into emergency OS update mode by holding down &lt;code&gt;[EXP]&lt;/code&gt;, &lt;code&gt;[^]&lt;/code&gt; and &lt;code&gt;[Clear]&lt;/code&gt; while pressing the reset button on the back of the calculator. We can then plug the calculator into the computer and run the update.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Steps of the updater, flashing our modified firmware" src="/assets/hacking-the-gc-part-2/update.png"&gt;&lt;/p&gt;
&lt;p&gt;We've now managed to load our own code onto the fx-CP400 and..... &lt;strong&gt;it works&lt;/strong&gt;! At least the software does, the video - not anywhere near as well.&lt;/p&gt;
&lt;div class="youtube-video"&gt;
        &lt;iframe type="text/html" src="https://www.youtube.com/embed/XlRt6AMSd2A?rel=0" frameborder="0"&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;&lt;em&gt;Concluding note: I managed to spill probably 25 mL of water over the graphics calculator while writing this post. Luckily it was mostly confined to the keypad section, but some water did manage to splash onto the screen. After a thorough disassembly and drying, the GC seems to have survived.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;The lesson is simple - don't leave partially full glasses of water on your desk when you're constantly reaching around. It's a really bad idea.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;If you're also interested how I recorded that video.... check out &lt;a href="/assets/hacking-the-gc-part-2/recording-setup.jpg"&gt;this&lt;/a&gt; image if you want to see some great amateur metal work.&lt;/em&gt;&lt;/p&gt;</content><category term="blog"></category><category term="reverse engineering"></category></entry><entry><title>Hacking the fx-CP400 - Part 1 (Getting the Firmware)</title><link href="https://the6p4c.github.io/2018/01/15/hacking-the-gc-part-1.html" rel="alternate"></link><published>2018-01-15T00:00:00+10:00</published><updated>2018-01-15T00:00:00+10:00</updated><author><name></name></author><id>tag:the6p4c.github.io,2018-01-15:/2018/01/15/hacking-the-gc-part-1.html</id><summary type="html">&lt;p&gt;Extracting the firmware image from a CASIO fx-CP400.&lt;/p&gt;</summary><content type="html">&lt;p&gt;When I began Year 11 in 2016 and was asked to buy a CASIO fx-CP400 graphics calculator, the hacker part of my brain immediately started wondering what mischief I could get up to by modifying the firmware. The 4.8 inch, 310 by 401 pixel color LCD, touch screen, and full physical number and operator keypad prompted many ideas of emulators and various fun pieces of software. Sadly, overcome with a fear of bricking the over $200 AUD calculator I absolutely needed for school, I didn't put much effort into hacking at the device.&lt;/p&gt;
&lt;p&gt;That is, until recently.&lt;/p&gt;
&lt;p&gt;In the past 6 months or so, I've spent a bit of time investigating the firmware and making sense of the mess that is the fx-CP400. This short series of blog posts will go into some detail about my investigation of the device and its firmware, and hopefully act as an insight into the reverse engineering process and maybe even demystify reverse engineering for those who are just beginning.&lt;/p&gt;
&lt;p&gt;These posts certainly won't be a tutorial, but more of a tour through my thought processes whilst undertaking work like this.&lt;/p&gt;
&lt;h1&gt;The calculator&lt;/h1&gt;
&lt;p&gt;&lt;img alt="The CASIO fx-CP400" src="/assets/hacking-the-gc-part-1/gc.png"&gt;&lt;/p&gt;
&lt;p&gt;For those who've never used one, the CASIO fx-CP400 is quite a well-featured graphing calculator. For $225 AUD (new), it boasts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A 4.8 inch, 310 by 401 pixel color LCD&lt;/li&gt;
&lt;li&gt;Touch screen, supporting up to two touch points&lt;/li&gt;
&lt;li&gt;Full physical numeric and operator keypad&lt;/li&gt;
&lt;li&gt;Interactive 2D and 3D graphing&lt;/li&gt;
&lt;li&gt;Symbolic calculation, including integration and differentiation, and algebraic expression expansion and simplification&lt;/li&gt;
&lt;li&gt;Spreadsheets and statistical calculation&lt;/li&gt;
&lt;li&gt;(Very) limited programmability in a BASIC-like language&lt;/li&gt;
&lt;li&gt;Full USB connectivity for data transfer&lt;/li&gt;
&lt;li&gt;Much more&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For a student, it was great to use and made many tedious exercises much easier. But that's only half the potential I think this device possesses.&lt;/p&gt;
&lt;h1&gt;Research&lt;/h1&gt;
&lt;p&gt;Before blindly jumping into reverse engineering the calculator, I made sure to do a bit of research into what others might have already discovered about the device. Quickly, I found a &lt;a href="https://www.omnimaga.org/news/classpad-ii-fx-cp400-hardware-a-hidden-sd-card-reader/"&gt;forum post&lt;/a&gt; with pictures of the internals of the device and revealing some key sequences which could open hidden debugging menus. Though initially exploring the debug menus didn't expose too much new information, their presence was helpful later when decompiling and investigating the firmware. But I didn't find much, if any, discussion of the firmware - only one mention of the existence of the 3069 and 3070 resources, and not much else. (Don't worry if you're confused - I'll discuss these later). &lt;/p&gt;
&lt;p&gt;The most important resource I found during the research process, though, was CASIO's web page for the fx-CP400 which offered a firmware update tool. Without this, hacking the device would have been exponentially harder.&lt;/p&gt;
&lt;h1&gt;Getting the firmware updater&lt;/h1&gt;
&lt;p&gt;With some initial research completed, the next goal was to get the firmware that runs on the calculator. Two options presented themselves - extract the firmware from the NAND flash chip on the device (a complicated, tedious and error prone process) or reverse engineer the Windows firmware update application. Without the necessary hardware (or patience) for the former, the only remaining option was to investigate the firmware updater.&lt;/p&gt;
&lt;p&gt;From the main web page for the CASIO fx-CP400, a firmware updater ZIP file containing an EXE installer can be downloaded.&lt;/p&gt;
&lt;ul class="filesystem"&gt;
    &lt;li class="filesystem-archive"&gt;
        cp2_update_2012_2b.zip
        &lt;ul&gt;
            &lt;li class="filesystem-file"&gt;CAS_color_graphic_OSver2_01_2000_Update.exe&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Running the executable yields an InstallShield installation wizard, which when "installed" (we'll address this soon) produces another window showing the steps that must be taken on the calculator to begin the firmware update procedure.&lt;/p&gt;
&lt;p&gt;&lt;img alt="The InstallShield wizard" src="/assets/hacking-the-gc-part-1/update-wizard.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="The firmware update application launched by the InstallShield wizard" src="/assets/hacking-the-gc-part-1/update-firmware.png"&gt;&lt;/p&gt;
&lt;p&gt;The weird behavior of the installer - giving no option for an install path, and immediately launching an application - made me suspicious that it wasn't actually installing anything. Instead, I believed the installer was instead simply acting as a way of containing and executing the firmware updater.&lt;/p&gt;
&lt;p&gt;To determine if this was the case, I used the invaluable tool &lt;a href="https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer"&gt;Process Explorer&lt;/a&gt; to view the subprocesses launched by the installer. Expecting to see a subprocess of the installer which was clearly the firmware updater, I was slightly surprised to see that the only subprocess was the Windows Installer process &lt;code&gt;msiexec.exe&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img alt="The subprocess msiexec.exe of the installer shown in Process Monitor" src="/assets/hacking-the-gc-part-1/process-monitor.png"&gt;&lt;/p&gt;
&lt;p&gt;As the &lt;code&gt;msiexec.exe&lt;/code&gt; process was clearly the workhorse (or launching the workhorse), I opened &lt;a href="https://docs.microsoft.com/en-us/sysinternals/downloads/procmon"&gt;Process Monitor&lt;/a&gt; and set a filter for &lt;code&gt;msiexec.exe&lt;/code&gt; to catch when the true firmware updater was extracted or run. Before even proceeding through the installer, a flurry of events shot past in Process Monitor. Though most were typical actions taken by a Windows process, a long stream of &lt;code&gt;FASTIO_WRITE&lt;/code&gt; events referencing an &lt;code&gt;OSupdateDLL.dll&lt;/code&gt; appear within the garbage. Opening the directory containing the DLL revealed the true firmware update utility.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot of Process Explorer showing the process msiexec.exe performing a FASTIO_WRITE operation on the file OSupdateDLL.dll" src="/assets/hacking-the-gc-part-1/process-explorer.png"&gt;&lt;/p&gt;
&lt;ul class="filesystem"&gt;
        &lt;li class="filesystem-directory"&gt;
                %TEMP\&amp;lt;random guid&amp;gt;\
                &lt;ul&gt;
                    &lt;li class="filesystem-file"&gt;fxASPI.dll&lt;/li&gt;
                    &lt;li class="filesystem-file"&gt;LanguageResource.dll&lt;/li&gt;
                    &lt;li class="filesystem-file"&gt;OSupdateDLL.dll&lt;/li&gt;
                &lt;/ul&gt;
        &lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;Getting the firmware&lt;/h1&gt;
&lt;p&gt;With the actual firmware updater in hand, it was now time to extract the firmware which was pushed to the device. Sadly, the directory contained no &lt;code&gt;firmware.bin&lt;/code&gt; or other obvious file, and as such the process became slightly harder. Almost immediately, however, the relatively large file size of &lt;code&gt;OSupdateDLL.dll&lt;/code&gt; - almost 10 MB - caught my eye. Due to its size, I was sure the firmware was contained within the DLL.&lt;/p&gt;
&lt;p&gt;With knowledge that large files can be stored inside PE files (EXEs, DLLs, etc.) in a section known as &lt;a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa381039(v=vs.85).aspx"&gt;RCDATA&lt;/a&gt;, I opened the DLL in &lt;a href="https://stefansundin.github.io/xn_resource_editor/"&gt;XN Resource Editor&lt;/a&gt; to see if any RCDATA sections were present within the DLL. Unsurprisingly, two sections (3069 and 3070) lay waiting. I extracted both for further investigation.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot of XN Resource Editor showing two RCDATA resources, 3069 and 3070" src="/assets/hacking-the-gc-part-1/rcdata.png"&gt;&lt;/p&gt;
&lt;p&gt;Viewing both sections in a hex editor revealed two similarities between the files. Both began with the two bytes &lt;code&gt;0xEC&lt;/code&gt; and &lt;code&gt;0xBD&lt;/code&gt;, and both appeared to be almost random data. Running the Unix &lt;code&gt;strings&lt;/code&gt; utility over both revealed no human-readable data, and examining both with the &lt;a href="https://github.com/ReFirmLabs/binwalk"&gt;&lt;code&gt;binwalk&lt;/code&gt;&lt;/a&gt; tool showed no helpful information and very high entropy. Uh oh. There's obviously some encryption and/or compression going on here.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Graphs showing entropy hovering around 1.0 for both 3069 and 3070" src="/assets/hacking-the-gc-part-1/binwalk-entropy.png"&gt;&lt;/p&gt;
&lt;p&gt;With hopes set on a simple or well-known compression algorithm undone by the firmware updater, I turned to disassembling the DLL file with IDA to find out how to get at the real firmware. Since the two binary blobs are located within the RCDATA of the DLL file, I started investigating by looking at the functions the DLL imports from the standard libraries which interact with PE resources. Since the function &lt;a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms648042(v=vs.85).aspx"&gt;&lt;code&gt;FindResource&lt;/code&gt;&lt;/a&gt; (and its &lt;code&gt;Ex&lt;/code&gt; and &lt;code&gt;W&lt;/code&gt; cousins) from &lt;code&gt;KERNEL32&lt;/code&gt; are used for this, it was my first port of call in the disassembly. Within the DLL, both the &lt;code&gt;FindResourceW&lt;/code&gt; and &lt;code&gt;FindResourceEx&lt;/code&gt; functions are imported, however the former is only used in a function called &lt;code&gt;AfxGetPropSheetFont&lt;/code&gt; - not very likely to be the function we want. However, the &lt;code&gt;FindResourceW&lt;/code&gt; function is used many times. This is probably the function we want to explore.&lt;/p&gt;
&lt;p&gt;&lt;img alt="IDA window \&amp;quot;xrefs to\&amp;quot; both FindResourceExW and FindResourceW" src="/assets/hacking-the-gc-part-1/osupdatedll-findresource-xrefs.png"&gt;&lt;/p&gt;
&lt;p&gt;Since we're about to jump head-first into some assembly, it's important to quickly go over the calling convention used by applications on Windows. If you're already familiar, you can safely skip this next paragraph.&lt;/p&gt;
&lt;p&gt;The calling convention of a platform is the method in which arguments are passed to functions and return values are passed back to the caller. On Windows, arguments to a function are passed through the stack, and pushed from right to left. That is, for a function &lt;code&gt;f(a, b, c)&lt;/code&gt; the arguments are pushed in the order &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, then &lt;code&gt;a&lt;/code&gt;. Most functions return their value in the &lt;code&gt;eax&lt;/code&gt; register, unless they return a more complicated data type such as a &lt;code&gt;float&lt;/code&gt; or a &lt;code&gt;double&lt;/code&gt;. If you're not an assembly expert, don't worry - I've tried to explain things as clearly as I can.&lt;/p&gt;
&lt;p&gt;To determine exactly which call to the function was responsible for unpacking the firmware, I used a conditional breakpoint. Examining the arguments for the &lt;code&gt;FindResourceW&lt;/code&gt; function showed that the index of the resource (3069 and 3070 our case) is passed into the function as the second argument of three (&lt;code&gt;lpName&lt;/code&gt;). It'll therefore be the second value on the stack, after the value of &lt;code&gt;lpType&lt;/code&gt;. To work out the offset we need to place on the stack pointer such that we can access the value of &lt;code&gt;lpName&lt;/code&gt;, we must find out how many bytes an &lt;a href="https://softwareengineering.stackexchange.com/a/194768/151006"&gt;&lt;code&gt;LPCTSTR&lt;/code&gt;&lt;/a&gt; is (the data type of &lt;code&gt;lpType&lt;/code&gt;). Looking through the Windows documentation shows the data type is 4 bytes long (it's a pointer), and as such our pointer will be &lt;code&gt;esp + 4&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;We can then set our breakpoint on the &lt;code&gt;FindResourceW&lt;/code&gt; function as shown. The following syntax is IDAPython, but the condition can also be written in IDC.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Breakpoint set with condition Dword(idc.GetRegValue(\&amp;quot;esp\&amp;quot;) + 4)==3069" src="/assets/hacking-the-gc-part-1/breakpoint-setup-1.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="Breakpoint shown in disassembly" src="/assets/hacking-the-gc-part-1/breakpoint-setup-2.png"&gt;&lt;/p&gt;
&lt;p&gt;Though we're ready to run the application and observe where our breakpoint is hit, we've got to set up the debugger. Since the file we're disassembling is a DLL and not an EXE, it can't be executed directly and the debugger in IDA must be configured to invoke the DLL appropriately. This is where the Windows utility &lt;code&gt;rundll32&lt;/code&gt; comes in handy to launch the required function. Examining the exports of the &lt;code&gt;OSupdateDLL.dll&lt;/code&gt; file shows two functions - &lt;code&gt;DllEntryPoint&lt;/code&gt; and &lt;code&gt;OSUpdate&lt;/code&gt;. We can assume that the latter is the true entry point to the DLL, and configure IDA to launch the DLL by invoking &lt;code&gt;rundll32&lt;/code&gt; with an argument specifying to call that function.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Debugger set up to run rundll32.exe with arguments OSupdateDLL.dll,OSUpdate" src="/assets/hacking-the-gc-part-1/debugger-setup.png"&gt;&lt;/p&gt;
&lt;p&gt;The breakpoint doesn't trigger straight away, but takes plugging in the calculator and running through the steps to begin the update for it to be hit. When it does, we're immediately shown the exact location within the code where our data is loaded.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Breakpoint hit, showing the call to the FindResourceW function where the condition is met" src="/assets/hacking-the-gc-part-1/breakpoint-triggered.png"&gt;&lt;/p&gt;
&lt;p&gt;Now begins the trickier part - deciphering the assembly to work out how the data is dealt with.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Disassembly of the function found with the breakpoint" src="/assets/hacking-the-gc-part-1/disassembly1.png"&gt;&lt;/p&gt;
&lt;p&gt;First, the function &lt;code&gt;FindResourceW&lt;/code&gt; is called with the ID of our resource (in &lt;code&gt;edi&lt;/code&gt;), which returns a handle to the resource. This handle is immediately pushed back onto the stack, becoming the &lt;code&gt;hResInfo&lt;/code&gt; argument to &lt;a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms648046(v=vs.85).aspx"&gt;&lt;code&gt;LoadResource&lt;/code&gt;&lt;/a&gt;. This function returns a handle to the data associated with the resource which is then saved in &lt;code&gt;[ebp+hResData]&lt;/code&gt; to be used later.&lt;/p&gt;
&lt;p&gt;As we're looking for somewhere which uses the data contained within the resource, we're most interested in the call to the &lt;a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms648047(v=vs.85).aspx"&gt;&lt;code&gt;LockResource&lt;/code&gt;&lt;/a&gt; function. We can see that the value of &lt;code&gt;[ebp+hResData]&lt;/code&gt; (the handle to the data, retrieved from the previous call to &lt;code&gt;LoadResource&lt;/code&gt;) is moved into &lt;code&gt;eax&lt;/code&gt; and then &lt;code&gt;eax&lt;/code&gt; pushed onto the stack to serve as the first argument of &lt;code&gt;LockResource&lt;/code&gt;. The function returns a pointer to the data, which is then saved in &lt;code&gt;[ebp+hModule]&lt;/code&gt; (now repurposed to store the pointer). The size of the data is also retrieved through &lt;a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms648048(v=vs.85).aspx"&gt;&lt;code&gt;SizeOfResource&lt;/code&gt;&lt;/a&gt;, and stored in &lt;code&gt;ebx&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;IDA usefully notes the name of the next function we're interested in - &lt;code&gt;operator new[](uint)&lt;/code&gt; - which is the constructor for a byte array. Here, some weird assembly tricks are used to calculate the size of the array we want to allocate. The size is calculated using the &lt;code&gt;lea&lt;/code&gt; instruction which is typically used to &lt;strong&gt;L&lt;/strong&gt;oad &lt;strong&gt;E&lt;/strong&gt;ffective &lt;strong&gt;A&lt;/strong&gt;ddress, i.e. load the address of a piece of data into a register. In this case, it's used to perform an addition and a move in one step, without effecting the contents of the original register. As square brackets in assembly are used to dereference a pointer (the &lt;code&gt;*&lt;/code&gt; prefix operator in C), &lt;code&gt;[ebx+0Bh]&lt;/code&gt; would typically dereference memory at the address &lt;code&gt;ebx + 0Bh&lt;/code&gt;. However, since it's used as an argument to the &lt;code&gt;lea&lt;/code&gt; instruction, the &lt;code&gt;eax&lt;/code&gt; register is loaded with the address of &lt;code&gt;[ebx+0Bh]&lt;/code&gt; which is simply &lt;code&gt;ebx+0Bh&lt;/code&gt;. This usage is basically equivalent to &lt;code&gt;mov eax, ebx+0Bh&lt;/code&gt;, since that instruction isn't possible.&lt;/p&gt;
&lt;p&gt;With that in mind, we can see the array is created with a length which is &lt;code&gt;0x0B == 11&lt;/code&gt; bytes longer than the actual size of the resource. The return value of the constructor (i.e. the pointer to the array, now stored in &lt;code&gt;esi&lt;/code&gt;) is tested for a null pointer and then execution jumps to the point below.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Disassembly of the function which is jumped to" src="/assets/hacking-the-gc-part-1/disassembly2.png"&gt;&lt;/p&gt;
&lt;p&gt;Here, quite a few memory operations act on the array we just created. First, the contents of the memory location &lt;code&gt;dword_10123390&lt;/code&gt; (helpfully named by IDA) are copied into the &lt;code&gt;ecx&lt;/code&gt; register, then the contents of the &lt;code&gt;ecx&lt;/code&gt; register copied into the first double word of the array. If you're more familiar with higher level languages, it may seem out of the ordinary to be copying a 4 byte data type into a byte array. But since we're dealing with the memory directly, it's bytes all the way down. Examining the contents of the memory location we copy from with IDA shows it contains the value &lt;code&gt;0x00088B1F&lt;/code&gt;. Naively, we'd assume the array would now look something like this:&lt;/p&gt;
&lt;div class="table-wrapper"&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;Index&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;0&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;...&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Data&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;0x00&lt;/td&gt;
&lt;td&gt;0x08&lt;/td&gt;
&lt;td&gt;0x8B&lt;/td&gt;
&lt;td&gt;0x1F&lt;/td&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;p&gt;But we've forgotten one important difference between processors - endianness. This is simply the order in which the bytes of a multi-byte number are stored in memory. On a little-endian machine, the number above would be stored in memory with the least significant byte first. The reverse is true on a big-endian machine, where the most significant byte is stored first. For example, if the number &lt;code&gt;0x12345678&lt;/code&gt; was stored at a memory address &lt;code&gt;x&lt;/code&gt;:&lt;/p&gt;
&lt;div class="table-wrapper"&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;Address&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;code&gt;x+0&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;&lt;code&gt;x+1&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;&lt;code&gt;x+2&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;&lt;code&gt;x+3&lt;/code&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Little-endian Data&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0x78&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0x56&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0x34&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0x12&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Big-endian Data&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0x12&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0x34&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0x56&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0x78&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;p&gt;Since our machine is little-endian, after the copy, our array actually looks like this:&lt;/p&gt;
&lt;div class="table-wrapper"&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;Index&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;0&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;...&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Data&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;0x1F&lt;/td&gt;
&lt;td&gt;0x8B&lt;/td&gt;
&lt;td&gt;0x08&lt;/td&gt;
&lt;td&gt;0x00&lt;/td&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;p&gt;This process is repeated, copying the contents of &lt;code&gt;dword_10123394&lt;/code&gt; (value 0) into our array, starting at index 4. The contents of &lt;code&gt;word_10123398&lt;/code&gt; (value &lt;code&gt;0x0004&lt;/code&gt;) are then copied into our array starting at index 8, this time only writing two bytes due to the size of a word and the &lt;code&gt;ax&lt;/code&gt; register (16 bits/2 bytes). Our array now looks like this:&lt;/p&gt;
&lt;div class="table-wrapper"&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;Index&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;0&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;th&gt;5&lt;/th&gt;
&lt;th&gt;6&lt;/th&gt;
&lt;th&gt;7&lt;/th&gt;
&lt;th&gt;8&lt;/th&gt;
&lt;th&gt;9&lt;/th&gt;
&lt;th&gt;...&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Data&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;0x1F&lt;/td&gt;
&lt;td&gt;0x8B&lt;/td&gt;
&lt;td&gt;0x08&lt;/td&gt;
&lt;td&gt;0x00&lt;/td&gt;
&lt;td&gt;0x00&lt;/td&gt;
&lt;td&gt;0x00&lt;/td&gt;
&lt;td&gt;0x00&lt;/td&gt;
&lt;td&gt;0x00&lt;/td&gt;
&lt;td&gt;0x04&lt;/td&gt;
&lt;td&gt;0x00&lt;/td&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;p&gt;We then call &lt;a href="https://msdn.microsoft.com/en-us/library/aa246468(v=vs.60).aspx"&gt;&lt;code&gt;_memcpy&lt;/code&gt;&lt;/a&gt; to begin the bulk of our copying operation - moving part of the contents of the resource into our array. Initially, the value &lt;code&gt;0x2FF6&lt;/code&gt; is pushed onto the stack to serve as the &lt;code&gt;count&lt;/code&gt; argument to &lt;code&gt;memcpy&lt;/code&gt;. The address pointing to the resource data, previously returned by &lt;code&gt;LockResource&lt;/code&gt; and stored in &lt;code&gt;[ebp+hModule]&lt;/code&gt;, is moved into &lt;code&gt;ecx&lt;/code&gt; and pushed onto the stack to serve as the source argument. The pointer to the array we allocated is also pushed to the stack, with the value &lt;code&gt;0xA&lt;/code&gt; added to it. This means the pointer no longer points to the first byte of the array, but the value at index &lt;code&gt;0xA&lt;/code&gt; - the first byte after the bytes we previously copied in. In C, this operation is as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;memcpy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0xA&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;resourceData&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x2FF6&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Our array now looks like this.&lt;/p&gt;
&lt;div class="table-wrapper"&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;Index&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;...&lt;/th&gt;
&lt;th&gt;0x8&lt;/th&gt;
&lt;th&gt;0x9&lt;/th&gt;
&lt;th&gt;0xA - 0x2FFF&lt;/th&gt;
&lt;th&gt;...&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Data&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;td&gt;0x04&lt;/td&gt;
&lt;td&gt;0x00&lt;/td&gt;
&lt;td&gt;&amp;lt;resource data 0x0 to 0x2FF5&amp;gt;&lt;/td&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;p&gt;An interesting operation then occurs - the value &lt;code&gt;0xBFD&lt;/code&gt; is subtracted from &lt;code&gt;edi&lt;/code&gt; (which stored the ID of the RCDATA resource we're currently operating on) and a conditional jump is performed. The operation &lt;code&gt;jz&lt;/code&gt; checks the zero flag and jumps if it's reset (zero). In our case, the zero bit is set if the result of the subtraction is 0, i.e. &lt;code&gt;edi - 0xBFD == 0&lt;/code&gt; or, much more simply, &lt;code&gt;edi == 0xBFD&lt;/code&gt;. If the jump isn't taken, the value of &lt;code&gt;edi&lt;/code&gt; is decremented by 1, and a conditional jump on the zero flag is again performed. This is equivalent to jumping if &lt;code&gt;edi - 0xBFD - 1 == 0&lt;/code&gt; or &lt;code&gt;edi == 0xBFE&lt;/code&gt;. These values - &lt;code&gt;0xBFD&lt;/code&gt; and &lt;code&gt;0xBFE&lt;/code&gt; are the values 3069 and 3070. Both jumps move code execution to two almost identical pieces of assembly.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Disassembly of the function which is jumped to" src="/assets/hacking-the-gc-part-1/disassembly3.png"&gt;&lt;/p&gt;
&lt;p&gt;Since both sections of code appear functionally identical, it's much quicker to analyze just one section and use what we've learned in the first section to quickly decipher the second. Here we'll analyze the section &lt;code&gt;loc_10003A3B&lt;/code&gt;, called when the resource ID is 3070. Two operations are interwoven here - a simple array access and a more complicated &lt;code&gt;memcpy&lt;/code&gt;. The address of the array is moved into &lt;code&gt;ecx&lt;/code&gt;, and the value &lt;code&gt;0xFFFFD00A&lt;/code&gt; added to the value of &lt;code&gt;ebx&lt;/code&gt;, which still contains the size of the resource in bytes. This addition is actually relying on integer overflow to perform a subtraction. Since the register &lt;code&gt;ebx&lt;/code&gt; is only 32-bit, when an addition occurs which sets a bit higher than can be represented in a 32-bit number, it's silently lost and the value wraps around. In this case, by adding &lt;code&gt;0xFFFFD00A&lt;/code&gt; to the length of our resource we effectively subtract &lt;code&gt;0x2FF6&lt;/code&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="w"&gt;               &lt;/span&gt;&lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x0FFFFFFFF&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="mh"&gt;0xFFFFD00A&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x1500000&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x1014FD00A&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x014FD00A&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="mh"&gt;0x1500000&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x2FF6&lt;/span&gt;&lt;span class="w"&gt;                    &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x014FD00A&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This newly calculated value is then pushed onto the stack, and IDA helpfully tells us this becomes the &lt;code&gt;count&lt;/code&gt; argument of &lt;code&gt;memcpy&lt;/code&gt; (by showing us the type is &lt;code&gt;size_t&lt;/code&gt;). &lt;code&gt;0x2FF6&lt;/code&gt; is added to &lt;code&gt;ecx&lt;/code&gt;, the address of our resource data, and pushed to the stack to become the source. Before the destination argument is pushed onto the stack, a single byte of the array is set. The byte &lt;code&gt;0x9B&lt;/code&gt; is copied to &lt;code&gt;[esi+2FF6h]&lt;/code&gt;. Since in the previous &lt;code&gt;memcpy&lt;/code&gt; operation, &lt;code&gt;0xA&lt;/code&gt; is added to &lt;code&gt;esi&lt;/code&gt; to point at the first byte after our header, the byte is actually copied to the index &lt;code&gt;0x2FF6 + 0x0A&lt;/code&gt;, or index &lt;code&gt;0x3000&lt;/code&gt;. The value &lt;code&gt;0x2FF7&lt;/code&gt; is added to &lt;code&gt;esi&lt;/code&gt; leaving it pointing to the index &lt;code&gt;0x3001&lt;/code&gt; of the array, and pushed to the stack to become the destination. The two operations are equivalent to the following C code.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;0x3000&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x9B&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;memcpy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0xA&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x2FF6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;resourceData&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x2FF6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;resourceLength&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x2FF6&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;If we spend a moment to work out exactly what these operations are intended to achieve, a much clearer picture emerges. First, we copy a 10 byte header to our array. Then, we copy &lt;code&gt;0x2FF6&lt;/code&gt; bytes from the beginning of our resource to the array at the index just after the header. Then, the byte at index &lt;code&gt;0x3000&lt;/code&gt; is set to a hard-coded value, and a copy of &lt;code&gt;&amp;lt;resource length&amp;gt; - 0x2FF6&lt;/code&gt; bytes to the position &lt;code&gt;0x3001&lt;/code&gt; in the array is performed. We've reconstructed a file whose header and a specific byte in the middle of the file has been removed. Our array now looks something like this:&lt;/p&gt;
&lt;div class="table-wrapper"&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;Index&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;...&lt;/th&gt;
&lt;th&gt;0x8&lt;/th&gt;
&lt;th&gt;0x9&lt;/th&gt;
&lt;th&gt;0xA - 0x2FFF&lt;/th&gt;
&lt;th&gt;0x3000&lt;/th&gt;
&lt;th&gt;0x3001 - end&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Data&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;td&gt;0x04&lt;/td&gt;
&lt;td&gt;0x00&lt;/td&gt;
&lt;td&gt;&amp;lt;resource data 0x0 to 0x2FF5&amp;gt;&lt;/td&gt;
&lt;td&gt;&amp;lt;missing byte&amp;gt;&lt;/td&gt;
&lt;td&gt;&amp;lt;resource data 0x2FF6 to end&amp;gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;p&gt;This process is the same for the other RCDATA resource, with the only difference being the value of the byte which is written at position &lt;code&gt;0x3000&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;It's now time to work out exactly what's done with the data in this buffer. The hard-coded header that's added to both files serves us well, and searching for &lt;code&gt;1F 8B 08&lt;/code&gt; on Google immediately reveals the data is a GZIP file. Now it's time to reconstruct our file and extract it, hopefully revealing a raw firmware image. We'll open the 3070 file in our favorite hex editor, and add the header and missing byte at &lt;code&gt;0x3000&lt;/code&gt; (after the header's added). I'll only do this for the main firmware in 3070, but the process is exactly the same for the firmware in 3069.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Header added to 3070 file and saved as 3070.gz" src="/assets/hacking-the-gc-part-1/header-added.png"&gt;&lt;/p&gt;
&lt;p&gt;We'll save this new file as &lt;code&gt;3070.gz&lt;/code&gt; so the gzip command utility recognizes it, extract it, and presto!&lt;/p&gt;
&lt;p&gt;&lt;img alt="File extracted by running gzip -dc 3070.gz &amp;gt; 3070 and strings file generated and shown with strings 3070 &amp;gt; 3070.strings; sed -n 1000,1050p 3070.strings" src="/assets/hacking-the-gc-part-1/extract.png"&gt;&lt;/p&gt;
&lt;p&gt;Soon enough, I'll write a Part 2 exploring the firmware image itself and the interesting SuperH architecture it runs upon. Thanks for reading this far. If there's anything I can improve on in my writing, I'd love to hear it, send your constructive criticism my way!&lt;/p&gt;</content><category term="blog"></category><category term="reverse engineering"></category></entry></feed>